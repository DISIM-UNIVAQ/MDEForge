module Diff2EcoreDiff2; -- Module Template
create Out : EcoreDiff from In : diff;

--########################INIZIO HELPER CHANGE#############################
--questi helpers in base al tipo di elemento puntato dal rightParent restituiscono true o false
--essi vengono usati nelle matched rule che hanno come elemento di modello sorgente un diffGroup per identificare il corretto match
--I DiffGroup identificano che l'elemento è stato modificato.
--La struttura dei metodi è molto simile cambiano solo il tipo con il quale effettuare il confronto
--viene anche controllota se il rightParent è diverso da OclUndefined in quando il diffGroup più esterno (quello più generale
--utilizzato solo per raccogliere tutte le differenze) ovviamente non ha nessun rightParent
helper def : isPackage(a : diff!DiffGroup) : Boolean = 
	if(a.rightParent<>OclUndefined)
			then if(a.rightParent.eClass().name='EPackage')
					then  true
					else self.debug(a.rightParent.eClass().name)=true
				 endif
			else false
	endif;
helper def : isClass(a : diff!DiffGroup) : Boolean = 
	if(a.rightParent<>OclUndefined)
			then if(a.rightParent.eClass().name='EClass')
					then  true
					else false
				 endif
			else false
	endif;
helper def : isReference(a : diff!DiffGroup) : Boolean = 
	if(a.rightParent<>OclUndefined)
			then if(a.rightParent.eClass().name='EReference')
					then  true
					else false
				 endif
			else false
	endif;
helper def : isAttribute(a : diff!DiffGroup) : Boolean = 
	if(a.rightParent<>OclUndefined)
			then if(a.rightParent.eClass().name='EAttribute')
					then  true
					else false
				 endif
			else false
	endif;
helper def : isDataType(a : diff!DiffElement) : Boolean = 
	if(a.rightParent<>OclUndefined)
			then if(a.rightParent.eClass().name='EDataType')
					then  true
					else false
				 endif
			else false
	endif;
--########################FINE HELPER CHANGE#############################

--########################INIZIO HELPER GESTIONE EREDITARIETA'#############################
--Questi helpers sono usati per la gestione dell'ereditarietà: 

--questo helper lista tutte le classi presente nel modello sorgente
helper def : listOfClass() : Sequence(diff!DiffElement) = 
	diff!DiffGroup.allInstancesFrom('In')->select(e | thisModule.isClass(e))->union(diff!ModelElementChangeLeftTarget.allInstancesFrom('In')->select(e | thisModule.isClassAdd(e)));


--questo helper  è invocato per risolvere la classe dalla quale si eredità
--restituisce l'elemento di modello sorgente dal quale ereditare: chi richiama questo metodo userà
--le resolveTemp(elementoRestituitoMetodo,"element")
helper def : getSuperClass2(nome : String) : diff!DiffElement = 
	thisModule.listOfClass()->any(e| 
		if(e.oclIsTypeOf(diff!DiffGroup))
			then e.rightParent.name=nome				
			else e.leftElement.name=nome
		endif);

helper def : listOfDataType() : Sequence(diff!DiffElement) = 
	diff!DiffGroup.allInstancesFrom('In')->select(e | thisModule.isDataType(e))->union(diff!ModelElementChangeLeftTarget.allInstancesFrom('In')->select(e | thisModule.isDataTypeAdd(e)));


--questo helper  è invocato per risolvere la classe dalla quale si eredità
--restituisce l'elemento di modello sorgente dal quale ereditare: chi richiama questo metodo userà
--le resolveTemp(elementoRestituitoMetodo,"element")
helper def : getSuperDataType(nome : String) : diff!DiffElement = 
	thisModule.listOfDataType()->any(e| 
		if(e.oclIsTypeOf(diff!DiffGroup))
			then e.rightParent.name=nome				
			else e.leftElement.name=nome
		endif);

helper def : isTypeDataType(nome : String) : Boolean = 
	if(nome='EString' or nome='EBoolean' or nome='EInt' or nome='EDouble')
		then true
		else false
	endif;
--		if(e.oclIsTypeOf(diff!DiffGroup))
--			then e.rightParent.name=nome				
--			else e.leftElement.name=nome
--		endif);

--helper def : getSuperClass(nome : String) : Boolean = if(thisModule.blabla(thisModule.getSuperClass('Element'))=true)then true else true endif;
--helper def : blabla(a : diff!DiffElement) : Boolean = if(a.oclIsTypeOf(diff!DiffGroup))then true else true endif;
--########################FINE HELPER GESTIONE EREDITARIETA'#############################


--########################INIZIO HELPER ADD#############################
--questi helpers in base al tipo di elemento puntato dal leftElement restituiscono true o false
--essi vengono usati nelle matched rule che hanno come elemento di modello sorgente un ModelElementChangeLeftTarget per identificare il corretto match
--I ModelElementChangeLeftTarget identificano che l'elemento è stato aggiunto.
--La struttura dei metodi è molto simile cambiano solo il tipo con il quale effettuare il confronto
helper def : isClassAdd(a : diff!ModelElementChangeLeftTarget) : Boolean = 
	if(a.oclIsTypeOf(diff!ModelElementChangeLeftTarget))
		then	
			if(a.leftElement.eClass().name='EClass')
				then  true
				else false
			endif
		else false
	endif;

helper def : isDataTypeAdd(a : diff!ModelElementChangeLeftTarget) : Boolean = 
	if(a.oclIsTypeOf(diff!ModelElementChangeLeftTarget))
		then	
			if(a.leftElement.eClass().name='EDataType')
				then  true
				else false
			endif
		else false
	endif;
helper def : isAttributeAdd(a : diff!ModelElementChangeLeftTarget) : Boolean = 
	if(a.leftElement.eClass().name='EAttribute')
			then  true
			else false
	endif;
helper def : isReferenceAdd(a : diff!ModelElementChangeLeftTarget) : Boolean = 
	if(a.leftElement.eClass().name='EReference')
			then  true
			else false
	endif;
helper def : isPackageAdd(a : diff!ModelElementChangeLeftTarget) : Boolean = 
	if(a.leftElement.eClass().name='EPackage')
			then  true
			else false
	endif;
--########################FINE HELPER ADD#############################

--########################INIZIO HELPER DELETE#############################
--questi helpers in base al tipo di elemento puntato dal rightElement restituiscono true o false
--essi vengono usati nelle matched rule che hanno come elemento di modello sorgente un ModelElementChangeRightTarget per identificare il corretto match
--I ModelElementChangeRightTarget identificano che l'elemento di modello è stato eliminato.
--La struttura dei metodi è molto simile cambiano solo il tipo con il quale effettuare il confronto
helper def : isClassDel(a : diff!ModelElementChangeRightTarget) : Boolean = 
	if(a.rightElement.eClass().name='EClass')
			then  true
			else false
	endif;

helper def : isAttributeDel(a : diff!ModelElementChangeRightTarget) : Boolean = 
	if(a.rightElement.eClass().name='EAttribute')
			then  true
			else false
	endif;

helper def : isReferenceDel(a : diff!ModelElementChangeRightTarget) : Boolean = 
	if(a.rightElement.eClass().name='EReference')
			then  true
			else false
	endif;

helper def : isPackageDel(a : diff!ModelElementChangeRightTarget) : Boolean = 
	if(a.rightElement.eClass().name='EPackage')
			then  true
			else false
	endif;

helper def : isDataTypeDel(a : diff!ModelElementChangeRightTarget) : Boolean = 
	if(a.rightElement.eClass().name='EDataType')
			then  true
			else false
	endif;
--########################FINE HELPER DELETE#############################
helper def : getNameClass(a : diff!DiffGroup) : String = 
	if(a.subDiffElements.first().oclIsTypeOf(diff!UpdateAttribute))
			then  a.subDiffElements.first().leftElement.name
			else a.rightParent.name
	endif;

--##############regola che inizializza la trasformazione#################
--dal rootNode del modello sorgente(ovviamente conforme al metamodello diff) 
--al rootNode del modello destinazione (ovviamente conforme al metamodello diff)
--questo elemento di modello destinazione conterrà tutti gli altri elementi di modello destinazione
--riferiti tramite resolveTemp()
rule Diff2Diff{
	from 
		s : diff!DiffModel
	to
		t : EcoreDiff!DifferenceModel
		(
			differenceElements <- s.ownedElements.first().subDiffElements->collect(e | thisModule.resolveTemp(e,'element')),
			differenceElements <- s.ownedElements.first().subDiffElements->collect(e | thisModule.resolveTemp(e,'sorgente'))
		)	
}

--########################INIZIO RULE INTERPRETARE DIFFGROUP#############################
--Il diffGroup è usato nel modello sorgente per identificare un cambiamento, per identificare cos'è cambiato bisogna osservare
--il tipo del rightParent dell'elemento di modello sorgente. Questo è realizzato usando gli helpers sopra definiti.

--Tale metodo permette la creazione dell'elemento di modello ChangedEPackage
--Se il tipo del rightParent è EPackage allora creerà un elemento di modello ChangedEPackage e il modello che sarà l'applicationElement(ovviamente di tipo Epackage)
--il ChangedEPackage element conterrà tutte le classe Changed/Added/Deleted (c/a/d) delle package che ha effettuato il match oltre alle c/a/d dei sottopackage
--l' EPackage soregente è il riferimento all'applicationElement di element
rule DiffGroup2ChangedPackage {
	from 
		sor : diff!DiffGroup (thisModule.isPackage(sor))
	to
		element : EcoreDiff!ChangedEPackage(
			name <- sor.rightParent.name,
			eClassifiers <- sor.subDiffElements->collect(e | thisModule.resolveTemp(e,'element')),
			eClassifiers <- sor.subDiffElements->collect(e | thisModule.resolveTemp(e,'sorgente')),
			eSubpackages <- sor.rightParent.eSubpackages->collect(e | thisModule.resolveTemp(e,'element')),
			eSubpackages <- sor.rightParent.eSubpackages->collect(e | thisModule.resolveTemp(e,'sorgente')),
			updatedElement <- sorgente,
			applicationElement <- sor.rightParent,
			eFactoryInstance <- sor.rightParent.eFactoryInstance
		),
		sorgente : EcoreDiff!EPackage(
			name <- sor.rightParent.name,
			eFactoryInstance <- sor.rightParent.eFactoryInstance
		)
}
--Tale metodo permette la creazione dell'elemento di modello ChangedEClass
--Se il tipo del rightParent è EClass allora creerà un elemento di modello ChangedEClass e il modello che sarà l'applicationElement(ovviamente di tipo EClass)
--il ChangedEClass element conterrà tutte gli attributi/reference/... Changed/Deleted (c/d) della Classe che ha effettuato il match 
--l' EClass soregente è il riferimento all'applicationElement di element e contiente attributi/reference/... aggiunti
--Per la gestione dell'ereditarietà viene usato l'helper getSuperClass2 sopra descritto che restituisce l'elemento di modello sorgente sul quele invocare le resolveTemp
rule DiffGroup2ChangedClass {
	from 
		sor : diff!DiffGroup  (thisModule.isClass(sor))
	to
		element : EcoreDiff!ChangedEClass(
			
			updatedElement <- sorgente,
			name <- thisModule.getNameClass(sor),
			eStructuralFeatures <- sor.subDiffElements->collect(e | thisModule.resolveTemp(e,'element')),
			applicationElement <- sor.rightParent,
			eSuperTypes <- sor.subDiffElements->select(e | e.oclIsTypeOf(diff!ReferenceChangeLeftTarget))->collect(e1 | thisModule.resolveTemp(thisModule.getSuperClass2(e1.leftTarget.name),'element'))
			
		),
		sorgente : EcoreDiff!EClass(
			eStructuralFeatures <- sor.subDiffElements->collect(e | thisModule.resolveTemp(e,'element_1')),
			name <- sor.rightParent.name
		)
}
--Tale metodo permette la creazione dell'elemento di modello ChangedEReference
--Se il tipo del rightParent è EReference creerà un elemento di modello ChangedEReference e il modello che sarà l'applicationElement(ovviamente di tipo AddedEReference)
--il ChangedEReference della reference cambiata 
--l' AddedEReference riporta le modifiche effettuate 
rule DiffGroup2ChangedReference {
	from 
		sor : diff!DiffGroup  (thisModule.isReference(sor))
	to
		element : EcoreDiff!ChangedEReference(
--			
			updatedElement <- element_1,
			name <- sor.rightParent.name,
			applicationElement <- sor.rightParent
		),
		element_1 : EcoreDiff!AddedEReference (
			name <- sor.subDiffElements.first().leftElement.name,
			lowerBound <- sor.subDiffElements.first().leftElement.lowerBound,
			upperBound <- sor.subDiffElements.first().leftElement.upperBound,
--			eType <- if (thisModule.isTypeDataType(sor.subDiffElements.first().leftElement))
--						then thisModule.resolveTemp(thisModule.getSuperDataType(sor.subDiffElements.first().leftElement.eType.name),'element')
--						else sor.subDiffElements.first().leftElement.eType
--					endif
			eType <- thisModule.resolveTemp(thisModule.getSuperClass2(sor.subDiffElements.first().leftElement.eType.name),'element')
			--eReferenceType <- thisModule.resolveTemp(thisModule.getSuperClass2(sor.subDiffElements.first().leftElement.eType.name),'element')
			-- eType <- sor.subDiffElements.first().leftElement.eType,
			--eOpposite <- sor.subDiffElements.first().leftElement.eOpposite
		)
}

--Tale metodo permette la creazione dell'elemento di modello ChangedEAttribute
--Se il tipo del rightParent è EAttribute creerà un elemento di modello ChangedEAttribute e il modello che sarà l'applicationElement(ovviamente di tipo AddedEAttribute)
--il ChangedEAttributo dell'attributo cambiato
--l' AddedEAttribute riporta le modifiche effettuate 
rule DiffGroup2ChangedAttribute {
	from 
		sor : diff!DiffGroup  (thisModule.isAttribute(sor))
	to
		element : EcoreDiff!ChangedEAttribute(
--			
			updatedElement <- element_1,
			name <- sor.rightParent.name,
			applicationElement <- sor.rightParent
		),
		element_1 : EcoreDiff!AddedEAttribute (
			name <- sor.subDiffElements.first().leftElement.name,
			lowerBound <- sor.subDiffElements.first().leftElement.lowerBound,
			upperBound <- sor.subDiffElements.first().leftElement.upperBound,
			eType <- if (thisModule.isTypeDataType(sor.leftElement.eType.name))
						then sor.sor.subDiffElements.first().leftElement.eType
						else thisModule.resolveTemp(thisModule.getSuperDataType(sor.subDiffElements.first().leftElement.eType.name),'element')
					endif,
			eAttributeType <- if (thisModule.isTypeDataType(sor.leftElement.eType.name))
						then sor.sor.subDiffElements.first().leftElement.eType
						else thisModule.resolveTemp(thisModule.getSuperDataType(sor.subDiffElements.first().leftElement.eType.name),'element')
					endif,
			eOpposite <- sor.subDiffElements.first().rightElement.eOpposite
			--errore
			--eType <- sor.subDiffElements.first().leftElement.eType,
			)
}
--Tale metodo permette la creazione dell'elemento di modello ChangedEDataType
--Se il tipo del rightParent è EDataType allora creerà un elemento di modello ChangedEDataType e il modello che sarà l'applicationElement(ovviamente di tipo EDataType)
--il ChangedEDataType element conterrà tutte i DataType cambiati dell DataType che ha effettuato il match 
--l' EDataType soregente è il riferimento all'applicationElement di element e contiente il DataType modificato
rule DiffGroup2ChangedDataType {
	from 
		sor : diff!DiffGroup  (thisModule.isDataType(sor))
	to
		element : EcoreDiff!ChangedEDataType(
--			
			updatedElement <- sorgente,
			name <- sor.rightParent.name,
			instanceClassName <- sor.subDiffElements.first().leftElement.instanceClassName,
			instanceTypeName <- sor.subDiffElements.first().leftElement.instanceTypeName,
			applicationElement <- sor.rightParent
			
		),
		sorgente: EcoreDiff!EDataType(
			name <- sor.rightParent.name
		)
}
--########################FINE RULE INTERPRETARE DIFFGROUP#############################


--########################INIZIO RULE INTERPRETARE ModelElementChangeLeftTarget(aggiunta) e ModelElementChangeRightTarget (eliminazione)#############################
--Tale metodo permette la creazione dell'elemento di modello AddedEPackage
--Se il tipo del leftElement è EPackage allora creerà un elemento di modello AddedEPackage
--l'elemento di modello destinazione AddedEPackage conterrà tutti gli elementi creati all'interno tutte le classi e i sottopackage
rule ModelElementChangeLeftTarget2AddedPackage {
	from
		sor: diff!ModelElementChangeLeftTarget (thisModule.isPackageAdd(sor))
	to
		element : EcoreDiff!AddedEPackage(
			name <- sor.leftElement.name,
			eClassifiers <- Sequence{sor.leftElement.eClassifiers->collect(e|thisModule.AddedClass(e))},
--			eSubpackages <- sor.rightParent.eSubpackages->collect(e | thisModule.resolveTemp(e,'element')),
--			eSubpackages <- sor.rightParent.eSubpackages->collect(e | thisModule.resolveTemp(e,'sorgente'))
			eSubpackages <- Sequence{sor.leftElement.eSubpackages->collect(e|thisModule.AddedPackage(e))}

		)
}
--Tale metodo permette la creazione dell'elemento di modello DeletedEPackage
--Se il tipo del rightElement è EPackage allora creerà un elemento di modello DeletedEPackage
--l'elemento di modello destinazione DeletedEPackage conterrà tutti gli elementi eliminati annidati (tutte le classi e i sottopackage) e punterà con l'applicationElement
--l'elemento del modello sorgente
rule ModelElementChangeRightTarget2DeletedPackage {
	from
		sor: diff!ModelElementChangeRightTarget (thisModule.isPackageDel(sor))
	to
		element : EcoreDiff!DeletedEPackage(
			name <- sor.rightElement.name,
			applicationElement <- sor.rightElement,
			eClassifiers <- Sequence{sor.rightElement.eClassifiers->collect(e|thisModule.DeleatedClass(e))},
			--eSubpackages <- sor.leftParent.eSubpackages->collect(e | thisModule.resolveTemp(e,'element')),
			--eSubpackages <- sor.leftParent.eSubpackages->collect(e | thisModule.resolveTemp(e,'sorgente'))
			eSubpackages <- Sequence{sor.rightElement.eClassifiers->collect(e|thisModule.DeleatedPackage(e))}
		)
}

--Tale metodo permette la creazione dell'elemento di modello AddedEClass
--Se il tipo del leftElement è EClass allora creerà un elemento di modello AddedEClass
--l'elemento di modello destinazione AddedEClass conterrà tutti le structural feature creati all'interno (attribute reference)
--Per la gestione dell'ereditarietà viene usato l'helper getSuperClass2 sopra descritto che restituisce l'elemento di modello sorgente sul quele invocare le resolveTemp
rule ModelElementChangeLeftTarget2AddedClass {
	from
		sor: diff!ModelElementChangeLeftTarget (thisModule.isClassAdd(sor))
	to
		element : EcoreDiff!AddedEClass(
			name <- sor.leftElement.name,
			eStructuralFeatures <- Sequence{sor.leftElement.eAttributes->collect(e|thisModule.AddedAtribute(e))}->union(sor.leftElement.eReferences->collect(e|thisModule.AddedReference(e))),
			eSuperTypes <- sor.leftElement.eSuperTypes->collect(e1 | thisModule.resolveTemp(thisModule.getSuperClass2(e1.name),'element'))
		)
}
--Tale metodo permette la creazione dell'elemento di modello DeletedEClass
--Se il tipo del rightElement è EClass allora creerà un elemento di modello DeletedEClass
--l'elemento di modello destinazione DeletedEPackage conterrà tutti gli elementi eliminati annidati (le classi e i sottopackage)
rule ModelElementChangeRightTarget2DeletedClass {
	from
		sor: diff!ModelElementChangeRightTarget (thisModule.isClassDel(sor))
	to
		element : EcoreDiff!DeletedEClass(
			name <- sor.rightElement.name,
			applicationElement <- sor.rightElement,
			eStructuralFeatures <- Sequence{sor.rightElement.eAttributes->collect(e|thisModule.DeleatedAttribute(e))}->union(sor.rightElement.eReferences->collect(e|thisModule.DeleatedReference(e)))
		)
}
--Tale metodo permette la creazione dell'elemento di modello AddedEDataType
--Se il tipo del leftElement è EDataType allora creerà un elemento di modello AddedEDataType
--l'elemento di modello destinazione AddedEDataType prenderà gli attributi settati
rule ModelElementChangeLeftTarget2AddedDataType {
	from
		sor: diff!ModelElementChangeLeftTarget (thisModule.isDataTypeAdd(sor))
	to
		element : EcoreDiff!AddedEDataType(
			name <- sor.leftElement.name,
			instanceClassName <- sor.leftElement.instanceClassName,
			instanceTypeName <- sor.leftElement.instanceTypeName
		)
}
--Tale metodo permette la creazione dell'elemento di modello DeletedEDataType
--Se il tipo del rightElement è EDataType allora creerà un elemento di modello DeletedEDataType
rule ModelElementChangeRightTarget2DeletedDataType {
	from
		sor: diff!ModelElementChangeRightTarget (thisModule.isDataTypeDel(sor))
	to
		element : EcoreDiff!DeletedEDataType(
			name <- sor.rightElement.name,
			applicationElement <- sor.rightElement
		)
}
--Tale metodo permette la creazione dell'elemento di modello AddedEAttribute
--Se il tipo del leftElement è EAttribute allora creerà un elemento di modello AddedEAttribute
--l'elemento di modello destinazione AddedEAttribute prenderà gli attributi settati
rule ModelElementChangeLeftTarget2AddedAttribute {
	from 
		sor: diff!ModelElementChangeLeftTarget (thisModule.isAttributeAdd(sor))
	to
		element : EcoreDiff!AddedEAttribute(
			name <- sor.leftElement.name,
			lowerBound <- sor.leftElement.lowerBound,
			upperBound <- sor.leftElement.upperBound,
			eType <- if (thisModule.isTypeDataType(sor.leftElement.eType.name))
						then sor.sor.subDiffElements.first().leftElement.eType
						else thisModule.resolveTemp(thisModule.getSuperDataType(sor.leftElement.eType.name),'element')
					endif,
			eAttributeType <- if (thisModule.isTypeDataType(sor.leftElement.eType.name))
						then sor.sor.subDiffElements.first().leftElement.eType
						else thisModule.resolveTemp(thisModule.getSuperDataType(sor.leftElement.eType.name),'element')
					endif
			--eType <- thisModule.resolveTemp(thisModule.getSuperDataType(sor.eType.name),'element')
			--errore
			--eType <- sor.leftElement.eType
			--eType <- thisModule.resolveTemp(thisModule.getSuperClass2(sor.leftElement.eType.name),'element')
		)
}
--Tale metodo permette la creazione dell'elemento di modello DeletedEAttribute
--Se il tipo del rightElement è EDataType allora creerà un elemento di modello DeletedEAttribute
rule ModelElementChangeRightTarget2DeletedAttribute {
	from 
		sor : diff!ModelElementChangeRightTarget (thisModule.isAttributeDel(sor))
	to
		element : EcoreDiff!DeletedEAttribute(
			name <- sor.rightElement.name,
			applicationElement <- sor.rightElement
			)
}
--	--##regola per l'aggiunta di una reference
rule ModelElementChangeLeftTarget2AddedReference {
	from 
		sor : diff!ModelElementChangeLeftTarget (thisModule.isReferenceAdd(sor))
	to
		element : EcoreDiff!AddedEReference(
			name <- sor.leftElement.name,
			lowerBound <- sor.leftElement.lowerBound,
			upperBound <- sor.leftElement.upperBound,
			eType <- thisModule.resolveTemp(thisModule.getSuperClass2(sor.leftElement.eType.name),'element')
			--eReferenceType <- thisModule.resolveTemp(thisModule.getSuperClass2(sor.leftElement.eType.name),'element')
			-- porta con se l'inter-model reference sbagliato
			--dovrei mettere una resolve temp all'etype corretto.
			--eType <- sor.leftElement.eType,
			--eOpposite <- sor.leftElement.eOpposite
		)
}
--	--##regole per l'eliminazione di una reference
rule ModelElementChangeRightTarget2DeleatedReference {
	from 
		sor : diff!ModelElementChangeRightTarget (thisModule.isReferenceDel(sor))
	to
		element : EcoreDiff!DeletedEReference
		(
			name <- sor.rightElement.name,
			applicationElement <- sor.rightElement
		)
}
--########################FINE RULE INTERPRETARE ModelElementChangeLeftTarget(aggiunta) e ModelElementChangeRightTarget (eliminazione)#############################



--########################INIZIO LAZY RULE per l'aggiunta e cancellazione degli elementi annidati(es: se ho una classe elimiata devo eliminare anche tutti le 
--structuralFeature contenute) #############################
--La struttura è simile in tutte le lazyRule cambia il tipo riferito.
lazy rule DeleatedAttribute {
	from
		s: diff!ModelElementChangeRightTarget
	to
		t: EcoreDiff!DeletedEAttribute(
			applicationElement <- s,
			name <- s.name
		)
}

lazy rule DeleatedReference {
	from
		s: diff!ModelElementChangeRightTarget
	to
		t: EcoreDiff!DeletedEReference(
			applicationElement <- s,
			name <- s.name
		)
}

lazy rule AddedAtribute {
	from 
		s : diff!EAttribute
	to
		t : EcoreDiff!AddedEAttribute(
			name<- s.name,
			eType <- if (thisModule.isTypeDataType(s.eType.name))
						then s.eType
						else thisModule.resolveTemp(thisModule.getSuperDataType(s.eType.name),'element')
					endif
--			eAttributeType <- if (thisModule.isTypeDataType(s.eType.name))
--						then s.eType
--						else thisModule.resolveTemp(thisModule.getSuperDataType(s.eType.name),'element')
--					endif
			--errore corretto
			--eType <- s.eType
			--eGenericType <- s.eGenericType
			--eType <- thisModule.resolveTemp(thisModule.getSuperDataType(s.eType.name),'element')
		)
}
--added reference
lazy rule AddedReference {
	from 
		s : diff!EReference
	to
		t : EcoreDiff!AddedEReference(
			name<- s.name,
			eType <- thisModule.resolveTemp(thisModule.getSuperClass2(s.eType.name),'element')
			--eReferenceType <- thisModule.resolveTemp(thisModule.getSuperClass2(s.eType.name),'element')
	)
}

lazy rule DeleatedClass {
	from
		s: diff!ModelElementChangeRightTarget
	to
		t: EcoreDiff!DeletedEClass(
			applicationElement <- s,
			name <- s.name,
			eStructuralFeatures <- Sequence{s.eAttributes->collect(e|thisModule.DeleatedAttribute(e))}->union(s.eReferences->collect(e|thisModule.DeleatedReference(e)))
		)
}

lazy rule AddedClass {
	from 
		s : diff!EClass
	to
		t: EcoreDiff!AddedEClass(
			name <- s.name,
			eStructuralFeatures <- Sequence{s.eAttributes->collect(e|thisModule.AddedAtribute(e))}->union(s.eReferences->collect(e|thisModule.AddedReference(e)))	
		)
}

lazy rule DeleatedPackage {
	from
		s: diff!ModelElementChangeRightTarget
	to
		t: EcoreDiff!DeletedEPackage(
			applicationElement <- s,
			name <- s.name,
			eClassifiers <- Sequence{s.eClassifiers->collect(e|thisModule.DeleatedClass(e))},
			eSubpackages <- s.eSubpackages->collect(e | thisModule.DeletedEPackage(e))
		)
}

lazy rule AddedPackage{
	from 
		s : diff!EClass
	to
		t: EcoreDiff!AddedEPackage(
			name <- s.name,
			eClassifiers <- Sequence{s.eClassifiers->collect(e|thisModule.AddedClass(e))},
			eSubpackages <- s.eSubpackages->collect(e | thisModule.AddedPackage(e))
		)
}
