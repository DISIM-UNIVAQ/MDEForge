-- @atlcompiler atl2006
-- generated by DUALLy
-- Department of Computer Science
-- University of L'Aquila

module DarwinFSP_A0_ManualCodeRight; -- Module Template
create OUT : DarwinFSP from IN : A0_Behavior;

lazy rule createType {
	from rightSide : A0_Behavior!"A0_Behavior::core::SAComponent"
	to leftSide : DarwinFSP!"DarwinFSP::Darwin::ComponentDeclaration"(
			name <- rightSide.name + 'Type')
	do {
		DarwinFSP!DarwinSpecification.allInstancesFrom('OUT').asSequence().first().componentDeclarations <- leftSide;
		leftSide;
	}
}

rule " ComponentInstance_SAComponent" {
  from
    rightSide : A0_Behavior!"A0_Behavior::core::SAComponent"
  to
    leftSide : DarwinFSP!"DarwinFSP::Darwin::ComponentInstance" (
      identifier <- rightSide.name,
      declaration <- rightSide.type.first()
    )
  do {
  		for( i in rightSide.subElement->select(e | e.oclIsKindOf(A0_Behavior!Component) and not rightSide.type.oclIsUndefined())) {
  			thisModule.resolveTemp(rightSide.type.first(), 'leftSide').innerInstances <- thisModule.resolveTemp(i, 'leftSide');
    	}
    	for( i in rightSide.subElement->select(e | e.oclIsKindOf(A0_Behavior!Link) and not rightSide.type.oclIsUndefined())) {
    		thisModule.resolveTemp(rightSide.type.first(), 'leftSide').innerBindings <- thisModule.resolveTemp(i, 'leftSide');
    	}
    	if(rightSide.type.isEmpty()) {
    		leftSide.declaration <- thisModule.createType(rightSide);
    	}
    	if(not rightSide.type.isEmpty() and not rightSide.behavior.isEmpty()) {
    		leftSide.declaration.relatedFSP <- thisModule.resolveTemp(rightSide.behavior.first(), 'leftSide');
    	}
	    thisModule.traces <- thisModule.traces.including(Tuple{source = rightSide, target = leftSide});
  }
}