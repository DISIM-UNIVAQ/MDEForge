
-- ******************************************************************************
-- Copyright (c) 2009 INRIA. 
-- All rights reserved. This program and the accompanying materials 
-- are made available under the terms of the Eclipse Public License v1.0 
-- which accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
-- 
-- Contributors: 
-- 	INRIA - Initial implementation
--  
-- ******************************************************************************

--@author Guillaume Doux (Guillaume . Doux <at> inria . fr)

module BPEL2XML; -- Module Template
create OUT : XML from IN : BPEL;

rule Process2Root{
	from
		s	:	BPEL!Process
	to
		t	:	XML!Root(
			name <- 'process',
			children <- Sequence{xmlns, name, tgnsp, plink, s.variables, s.activity}
		),
		xmlns	:	XML!Attribute(
			name <- 'xmlns',
			value <- 'http://docs.oasis-open.org/wsbpel/2.0/process/abstract'
		),
		name	:	XML!Attribute(
			name <- 'name',
			value <- s.name
		),
		tgnsp	:	XML!Attribute(
			name <- 'targetNamespace',
			value <- s.targetNamespace
		),
		plink	:	XML!Element(
			name <- 'partnerLinks'	
		)		
}


rule Variables2Element{
	from
		s	:	BPEL!Variables
	to
		var	:	XML!Element(
			name <- 'variables',
			children <- s.children
		)	
}

rule Variable2Element{
	from
		s	:	BPEL!Variable
	to
		t	:	XML!Element(
			name <- 'variable',
			children <- Sequence{na}
		),
		na	: XML!Attribute(
			name <- 'name',
			value <- s.name
		)
}

rule Receive2Element{
	from
		s	:	BPEL!Receive (s.createInstance.oclIsUndefined())
	to
		t	:	XML!Element(
			name <- 'receive',
			children <- Sequence{na}
		),
		na	:	XML!Attribute(
			name <- 'name',
			value <- s.name
		)
}

rule Receive2Element2{
	from
		s	:	BPEL!Receive (not s.createInstance.oclIsUndefined())
	to
		t	:	XML!Element(
			name <- 'receive',
			children <- Sequence{na, thisModule.Plink2Attribute(s.partnerLink), thisModule.PT2Attribute(s.portType), thisModule.Op2Attribute(s.operation), thisModule.Var2Attribute(s.variable), ci}
		),
		na	:	XML!Attribute(
			name <- 'name',
			value <- s.name
		),
		ci	:	XML!Attribute(
			name <- 'createInstance',
			value <- s.createInstance.toString()
		)
}



rule Invoke2Element{
	from
		s	:	BPEL!Invoke
	to
		t	:	XML!Element(
			name <- 'invoke',
			children <- Sequence{na, thisModule.Plink2Attribute(s.partnerLink), thisModule.PT2Attribute(s.portType), thisModule.Op2Attribute(s.operation), thisModule.inVar2Attribute(s.inputVariable), thisModule.outVar2Attribute(s.outputVariable)}
		),
		na	:	XML!Attribute(
			name <- 'name',
			value <- s.name
		)
}

lazy rule Plink2Attribute{
	from
		s	:	BPEL!PartnerLink
	to
		t	:	XML!Attribute(
			name <- 'partnerLink',
			value <- s.name
		)
}

lazy rule PT2Attribute{
	from
		s	:	BPEL!PortType
	to
		t	:	XML!Attribute(
			name <- 'portType',
			value <- s.qName
		)
}

lazy rule Op2Attribute{
	from
		s	:	BPEL!Operation
	to
		t	:	XML!Attribute(
			name <- 'operation',
			value <- s.name
		)
}

lazy rule Var2Attribute{
	from
		s	:	BPEL!PortType
	to
		t	:	XML!Attribute(
			name <- 'variable',
			value <- s.name
		)
}

lazy rule inVar2Attribute{
	from
		s	:	BPEL!PortType
	to
		t	:	XML!Attribute(
			name <- 'inputVariable',
			value <- s.name
		)
}

lazy rule outVar2Attribute{
	from
		s	:	BPEL!PortType
	to
		t	:	XML!Attribute(
			name <- 'outputVariable',
			value <- s.name
		)
}

rule switch2Element{
	from
		s	:	BPEL!Switch
	to
		t	:	XML!Element (
			name <- 'switch',
			children <- Sequence{s.cases, s.otherwise}->flatten()
		)
}

rule case2Element {
	from
		s	:	BPEL!Case
	to
		t	:	XML!Element (
			name <- 'case',
			children <- Sequence{s.condition, s.activity}->flatten()
		)
}

rule otherwise2Element {
	from
		s	:	BPEL!Otherwise
	to
		t	: XML!Element(
			name <- 'otherwise',
			children <- s.activity
		)
}

rule Condition2Attribute {
	from
		s	:	BPEL!Condition
	to
		t	:	XML!Attribute (
			name <- 'condition',
			value <- s.value
		)
}

rule Flows2Element {
	from
		s	:	BPEL!Flow
	to
		t	:	XML!Element(
			name <- 'flow',
			children <- Sequence{na, s.activities}->flatten()
		),
		na	:	XML!Attribute(
			name <- 'name',
			value <- s.name
		)	
}


rule while2Element {
	from
		s	:	BPEL!While
	to
		t	:	XML!Element(
			name <- 'while',
			children <- Sequence{s.condition, s.activity}
		)
}

rule sequence2Element {
	from
		s	:	BPEL!"Sequence" (s.name.oclIsUndefined())
	to
		t	:	XML!Element(
			name <- 'sequence',
			children <- s.activities
		)
}

rule sequence2Elementbis {
	from
		s	:	BPEL!"Sequence" (not s.name.oclIsUndefined())
	to
		t	:	XML!Element(
			name <- 'sequence',
			children <- Sequence{na, s.activities}->flatten()
		),
		na	:	XML!Attribute(
			name <- 'name',
			value <- s.name
		)	
}

rule wait2element {
	from
		s	:	BPEL!Wait
	to
		t	:	XML!Element(
			name <- 'wait',
			children <- Sequence{na}
		),
		na	:	XML!Attribute(
			name <- 'name',
			value <- s.name
		)	
}

rule onMessage2element {
	from
		s	:	BPEL!OnMessage
	to
		t	:	XML!Element(
			name <- 'onMessage',
			children <- Sequence{na}
		),
		na	:	XML!Attribute(
			name <- 'name',
			value <- s.name
		)	
}

rule alarm2element {
	from
		s	:	BPEL!Wait
	to
		t	:	XML!Element(
			name <- 'onAlarm',
			children <- Sequence{na}
		),
		na	:	XML!Attribute(
			name <- 'name',
			value <- s.name
		)	
}

rule empty2element {
	from
		s	:	BPEL!Empty
	to
		t	:	XML!Element(
			name <- 'empty'
		)	
}