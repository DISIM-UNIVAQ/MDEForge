-- @atlcompiler atl2006
-- author: Ivano Malavolta ivano.malavolta@univaq.it
-- Department of Computer Science
-- University of L'Aquila

-- HOT transformation that adds a statement preserving the xmiID of the source model
-- while passing to the target model
module IdPreservationHOT;

create OUT : ATL from IN : ATL;

helper def : inElements : Set(OclAny) = ATL!LocatedElement.allInstancesFrom('IN');
helper def : outModule : ATL!Module = OclUndefined;
helper def : GENcomment : String = '-- GENERATED by IdPreservationHOT';


endpoint rule addtraces() {
	do {
		thisModule.outModule <- ATL!Module.allInstancesFrom('OUT').first();
		thisModule.generateTracingHelper();
		thisModule.generateEndpointRule();
		for(e in thisModule.outModule.elements->select(e2 | e2.oclIsKindOf(ATL!MatchedRule))) {
			thisModule.generateTracingStatement(e);
		}
	}
}

-- add the helper keeping track of the trace links generated while transforming
rule generateTracingHelper() {
	using {
		tracingHelper : ATL!Helper = OclUndefined;
	}
	do {
		tracingHelper <- 'helper def : traces : Sequence(TupleType(source : OclAny, target : OclAny)) = Sequence{};'
		.inject('OUT', 'ebnf2', 'ATL-helper');
		tracingHelper.commentsBefore <- Sequence{thisModule.GENcomment};
		thisModule.outModule.elements <- tracingHelper;
	}
}

-- add the endpoint rule that sets the xmiID of each target model element according
-- to the tracing information obtained while transforming
rule generateEndpointRule() {
	using {
		endpointRule : ATL!CalledRule = OclUndefined;
	}
	do {
		endpointRule <- 
		('endpoint rule setTraces() {' +
		'do {\n' +
		'for(e in thisModule.traces) {\n' +
	   	' 	e.target.setElementIDbyRefType(\'ElementRefXMI\', e.source.getElementIDbyRefType(\'ElementRefXMI\'));\n' +
		'}\n' +
		'}\n' +
		'}\n').inject('OUT', 'ebnf2', 'ATL-calledRule');
		endpointRule.commentsBefore <- Sequence{thisModule.GENcomment};
		thisModule.outModule.elements <- endpointRule;
	}
}

-- for each matched rule, generate a statement in its action block so that
-- we keep track of the source and target elements of the rule being executed
rule generateTracingStatement(r : ATL!MatchedRule) {
	using {
		statement : ATL!Statement = OclUndefined;
	}
	do {
		statement <- 
		('thisModule.traces <- thisModule.traces.including(Tuple{source = ' + r.inPattern.elements.first().varName + ', target = ' + r.outPattern.elements.first().varName +'});').inject('OUT', 'ebnf2', 'ATL-statement');
		statement.commentsBefore <- Sequence{thisModule.GENcomment};
		r.actionBlock.statements <- statement;
	}
}

--- copying rules for each metaclass of the ATL metamodel

rule Unit {
 from s : ATL!Unit (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(ATL!Unit)
 else false endif)
 to t : ATL!Unit (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 libraries <- s.libraries)
}

rule Library {
 from s : ATL!Library (thisModule.inElements->includes(s))
 to t : ATL!Library (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 libraries <- s.libraries,
 helpers <- s.helpers)
}

rule Query {
 from s : ATL!Query (thisModule.inElements->includes(s))
 to t : ATL!Query (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 libraries <- s.libraries,
 body <- s.body,
 helpers <- s.helpers)
}

rule Module {
 from s : ATL!Module (thisModule.inElements->includes(s))
 to t : ATL!Module (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 isRefining <- s.isRefining,
 libraries <- s.libraries,
 inModels <- s.inModels,
 outModels <- s.outModels,
 elements <- s.elements)
}

rule Helper {
 from s : ATL!Helper (thisModule.inElements->includes(s))
 to t : ATL!Helper (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 definition <- s.definition)
}

rule MatchedRule {
 from s : ATL!MatchedRule (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(ATL!MatchedRule)
 else false endif)
 to t : ATL!MatchedRule (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 isAbstract <- s.isAbstract,
 isRefining <- s.isRefining,
 isNoDefault <- s.isNoDefault,
 outPattern <- s.outPattern,
 actionBlock <- s.actionBlock,
 variables <- s.variables,
 inPattern <- s.inPattern,
 children <- s.children,
 superRule <- s.superRule)
}

rule LazyMatchedRule {
 from s : ATL!LazyMatchedRule (thisModule.inElements->includes(s))
 to t : ATL!LazyMatchedRule (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 isAbstract <- s.isAbstract,
 isRefining <- s.isRefining,
 isNoDefault <- s.isNoDefault,
 isUnique <- s.isUnique,
 outPattern <- s.outPattern,
 actionBlock <- s.actionBlock,
 variables <- s.variables,
 inPattern <- s.inPattern,
 children <- s.children,
 superRule <- s.superRule)
}

rule CalledRule {
 from s : ATL!CalledRule (thisModule.inElements->includes(s))
 to t : ATL!CalledRule (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 isEntrypoint <- s.isEntrypoint,
 isEndpoint <- s.isEndpoint,
 outPattern <- s.outPattern,
 actionBlock <- s.actionBlock,
 variables <- s.variables,
 parameters <- s.parameters)
}

rule InPattern {
 from s : ATL!InPattern (thisModule.inElements->includes(s))
 to t : ATL!InPattern (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 elements <- s.elements,
 filter <- s.filter)
}

rule OutPattern {
 from s : ATL!OutPattern (thisModule.inElements->includes(s))
 to t : ATL!OutPattern (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 elements <- s.elements)
}

rule SimpleInPatternElement {
 from s : ATL!SimpleInPatternElement (thisModule.inElements->includes(s))
 to t : ATL!SimpleInPatternElement (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp,
 "mapsTo" <- s."mapsTo",
 models <- s.models)
}

rule SimpleOutPatternElement {
 from s : ATL!SimpleOutPatternElement (thisModule.inElements->includes(s))
 to t : ATL!SimpleOutPatternElement (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp,
 sourceElement <- s.sourceElement,
 bindings <- s.bindings,
 model <- s.model
 )
}

rule ForEachOutPatternElement {
 from s : ATL!ForEachOutPatternElement (thisModule.inElements->includes(s))
 to t : ATL!ForEachOutPatternElement (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp,
 sourceElement <- s.sourceElement,
 bindings <- s.bindings,
 model <- s.model,
 collection <- s.collection,
 iterator <- s.iterator)
}

rule Binding {
 from s : ATL!Binding (thisModule.inElements->includes(s))
 to t : ATL!Binding (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName,
 value <- s.value)
}

rule RuleVariableDeclaration {
 from s : ATL!RuleVariableDeclaration (thisModule.inElements->includes(s))
 to t : ATL!RuleVariableDeclaration (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp)
}

rule LibraryRef {
 from s : ATL!LibraryRef (thisModule.inElements->includes(s))
 to t : ATL!LibraryRef (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name)
}

rule ActionBlock {
 from s : ATL!ActionBlock (thisModule.inElements->includes(s))
 to t : ATL!ActionBlock (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 statements <- s.statements)
}

rule ExpressionStat {
 from s : ATL!ExpressionStat (thisModule.inElements->includes(s))
 to t : ATL!ExpressionStat (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 expression <- s.expression)
}

rule BindingStat {
 from s : ATL!BindingStat (thisModule.inElements->includes(s))
 to t : ATL!BindingStat (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName,
 source <- s.source,
 value <- s.value)
}

rule IfStat {
 from s : ATL!IfStat (thisModule.inElements->includes(s))
 to t : ATL!IfStat (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 condition <- s.condition,
 thenStatements <- s.thenStatements,
 elseStatements <- s.elseStatements)
}

rule ForStat {
 from s : ATL!ForStat (thisModule.inElements->includes(s))
 to t : ATL!ForStat (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 iterator <- s.iterator,
 collection <- s.collection,
 statements <- s.statements)
}

rule VariableExp {
 from s : ATL!VariableExp (thisModule.inElements->includes(s))
 to t : ATL!VariableExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 referredVariable <- s.referredVariable)
}

rule SuperExp {
 from s : ATL!SuperExp (thisModule.inElements->includes(s))
 to t : ATL!SuperExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type)
}

rule StringExp {
 from s : ATL!StringExp (thisModule.inElements->includes(s))
 to t : ATL!StringExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 stringSymbol <- s.stringSymbol,
 type <- s.type)
}

rule BooleanExp {
 from s : ATL!BooleanExp (thisModule.inElements->includes(s))
 to t : ATL!BooleanExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 booleanSymbol <- s.booleanSymbol,
 type <- s.type)
}

rule RealExp {
 from s : ATL!RealExp (thisModule.inElements->includes(s))
 to t : ATL!RealExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 realSymbol <- s.realSymbol,
 type <- s.type)
}

rule IntegerExp {
 from s : ATL!IntegerExp (thisModule.inElements->includes(s))
 to t : ATL!IntegerExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 integerSymbol <- s.integerSymbol,
 type <- s.type)
}

rule BagExp {
 from s : ATL!BagExp (thisModule.inElements->includes(s))
 to t : ATL!BagExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 elements <- s.elements)
}

rule OrderedSetExp {
 from s : ATL!OrderedSetExp (thisModule.inElements->includes(s))
 to t : ATL!OrderedSetExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 elements <- s.elements)
}

rule SequenceExp {
 from s : ATL!SequenceExp (thisModule.inElements->includes(s))
 to t : ATL!SequenceExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 elements <- s.elements)
}

rule SetExp {
 from s : ATL!SetExp (thisModule.inElements->includes(s))
 to t : ATL!SetExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 elements <- s.elements)
}

rule TupleExp {
 from s : ATL!TupleExp (thisModule.inElements->includes(s))
 to t : ATL!TupleExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 tuplePart <- s.tuplePart)
}

rule TuplePart {
 from s : ATL!TuplePart (thisModule.inElements->includes(s))
 to t : ATL!TuplePart (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp)
}

rule MapExp {
 from s : ATL!MapExp (thisModule.inElements->includes(s))
 to t : ATL!MapExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 elements <- s.elements)
}

rule MapElement {
 from s : ATL!MapElement (thisModule.inElements->includes(s))
 to t : ATL!MapElement (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 key <- s.key,
 value <- s.value)
}

rule EnumLiteralExp {
 from s : ATL!EnumLiteralExp (thisModule.inElements->includes(s))
 to t : ATL!EnumLiteralExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule OclUndefinedExp {
 from s : ATL!OclUndefinedExp (thisModule.inElements->includes(s))
 to t : ATL!OclUndefinedExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type)
}

rule NavigationOrAttributeCallExp {
 from s : ATL!NavigationOrAttributeCallExp (thisModule.inElements->includes(s))
 to t : ATL!NavigationOrAttributeCallExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 source <- s.source)
}

rule OperationCallExp {
 from s : ATL!OperationCallExp (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(ATL!OperationCallExp)
 else false endif)
 to t : ATL!OperationCallExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 operationName <- s.operationName,
 type <- s.type,
 source <- s.source,
 arguments <- s.arguments)
}

rule OperatorCallExp {
 from s : ATL!OperatorCallExp (thisModule.inElements->includes(s))
 to t : ATL!OperatorCallExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 operationName <- s.operationName,
 type <- s.type,
 source <- s.source,
 arguments <- s.arguments)
}

rule CollectionOperationCallExp {
 from s : ATL!CollectionOperationCallExp (thisModule.inElements->includes(s))
 to t : ATL!CollectionOperationCallExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 operationName <- s.operationName,
 type <- s.type,
 source <- s.source,
 arguments <- s.arguments)
}

rule IterateExp {
 from s : ATL!IterateExp (thisModule.inElements->includes(s))
 to t : ATL!IterateExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 source <- s.source,
 body <- s.body,
 iterators <- s.iterators,
 result <- s.result)
}

rule IteratorExp {
 from s : ATL!IteratorExp (thisModule.inElements->includes(s))
 to t : ATL!IteratorExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 source <- s.source,
 body <- s.body,
 iterators <- s.iterators)
}

rule LetExp {
 from s : ATL!LetExp (thisModule.inElements->includes(s))
 to t : ATL!LetExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 variable <- s.variable,
 in_ <- s.in_)
}

rule IfExp {
 from s : ATL!IfExp (thisModule.inElements->includes(s))
 to t : ATL!IfExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 thenExpression <- s.thenExpression,
 condition <- s.condition,
 elseExpression <- s.elseExpression)
}

rule VariableDeclaration {
 from s : ATL!VariableDeclaration (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(ATL!VariableDeclaration)
 else false endif)
 to t : ATL!VariableDeclaration (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp)
}

rule Iterator {
 from s : ATL!Iterator (thisModule.inElements->includes(s))
 to t : ATL!Iterator (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp)
}

rule Parameter {
 from s : ATL!Parameter (thisModule.inElements->includes(s))
 to t : ATL!Parameter (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp)
}

rule CollectionType {
 from s : ATL!CollectionType (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(ATL!CollectionType)
 else false endif)
 to t : ATL!CollectionType (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 elementType <- s.elementType)
}

rule "OclType" {
 from s : ATL!"OclType" (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(ATL!"OclType")
 else false endif)
 to t : ATL!"OclType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule StringType {
 from s : ATL!StringType (thisModule.inElements->includes(s))
 to t : ATL!StringType (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule BooleanType {
 from s : ATL!BooleanType (thisModule.inElements->includes(s))
 to t : ATL!BooleanType (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule IntegerType {
 from s : ATL!IntegerType (thisModule.inElements->includes(s))
 to t : ATL!IntegerType (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule RealType {
 from s : ATL!RealType (thisModule.inElements->includes(s))
 to t : ATL!RealType (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule BagType {
 from s : ATL!BagType (thisModule.inElements->includes(s))
 to t : ATL!BagType (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 elementType <- s.elementType)
}

rule OrderedSetType {
 from s : ATL!OrderedSetType (thisModule.inElements->includes(s))
 to t : ATL!OrderedSetType (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 elementType <- s.elementType)
}

rule SequenceType {
 from s : ATL!SequenceType (thisModule.inElements->includes(s))
 to t : ATL!SequenceType (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 elementType <- s.elementType)
}

rule SetType {
 from s : ATL!SetType (thisModule.inElements->includes(s))
 to t : ATL!SetType (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 elementType <- s.elementType)
}

rule OclAnyType {
 from s : ATL!OclAnyType (thisModule.inElements->includes(s))
 to t : ATL!OclAnyType (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule "TupleType" {
 from s : ATL!"TupleType" (thisModule.inElements->includes(s))
 to t : ATL!"TupleType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 attributes <- s.attributes)
}

rule TupleTypeAttribute {
 from s : ATL!TupleTypeAttribute (thisModule.inElements->includes(s))
 to t : ATL!TupleTypeAttribute (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule OclModelElement {
 from s : ATL!OclModelElement (thisModule.inElements->includes(s))
 to t : ATL!OclModelElement (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 model <- s.model)
}

rule MapType {
 from s : ATL!MapType (thisModule.inElements->includes(s))
 to t : ATL!MapType (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 valueType <- s.valueType,
 keyType <- s.keyType)
}

rule OclFeatureDefinition {
 from s : ATL!OclFeatureDefinition (thisModule.inElements->includes(s))
 to t : ATL!OclFeatureDefinition (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 feature <- s.feature,
 context_ <- s.context_)
}

rule OclContextDefinition {
 from s : ATL!OclContextDefinition (thisModule.inElements->includes(s))
 to t : ATL!OclContextDefinition (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 context_ <- s.context_)
}

rule Attribute {
 from s : ATL!Attribute (thisModule.inElements->includes(s))
 to t : ATL!Attribute (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 initExpression <- s.initExpression,
 type <- s.type)
}

rule Operation {
 from s : ATL!Operation (thisModule.inElements->includes(s))
 to t : ATL!Operation (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 parameters <- s.parameters,
 returnType <- s.returnType,
 body <- s.body)
}

rule OclModel {
 from s : ATL!OclModel (thisModule.inElements->includes(s))
 to t : ATL!OclModel (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 metamodel <- s.metamodel,
 elements <- s.elements,
 model <- s.model)
}



