-- @nsURI Ecore=http://www.eclipse.org/emf/2002/Ecore
-- @nsURI Ecore=http://www.eclipse.org/emf/2002/Ecore

module MM2UMM;
create OUT :  Ecore from IN :Ecore;

helper def :inElements : Set(MM!"ecore::EObject") =Ecore!"ecore::EObject".allInstancesFrom('IN');
helper def :eStringType:  Ecore!EDataType =  Ecore!EDataType.allInstancesFrom(' Ecore')->select(e | e.name = 'EString').first();
helper def :eObjectType:  Ecore!EDataType =Ecore!EObject; 
helper def :traceableMetaclass :  Ecore!EClass = OclUndefined;

entrypoint rule Metamodel() {
	to tr :  Ecore!EClass (
			name <- 'Traceable',
			"abstract" <- true,
			eAttributes <- Sequence{}->append(att)->append(ref)),
		att: Ecore!EAttribute (
			name <- 'trace',
			eType <- thisModule.eStringType),
		ref: Ecore!EAttribute (
			name <- 'ref',
			eType <- thisModule.eObjectType,
			lowerBound <- 0,
			upperBound <- -1)
	do {
		thisModule.traceableMetaclass <- tr;
	}
}
	
rule EPackage {
	from s :Ecore!EPackage (thisModule.inElements->includes(s))
	to t :  Ecore!EPackage (
		name <- s.name,
		nsURI <- s.nsURI,
		nsPrefix <- s.nsPrefix,
		eAnnotations <- s.eAnnotations,
		eFactoryInstance <- s.eFactoryInstance,
		eClassifiers <- s.eClassifiers->union(s.eClassifiers->collect( e | thisModule.resolveTemp(e, 'u')))->append(thisModule.traceableMetaclass),
		eSubpackages <- s.eSubpackages)		
}

rule EClass2EClass {
	from s :Ecore!EClass ((thisModule.inElements->includes(s)) and ((s.eSuperTypes->size()>0)
																or (s."abstract"='true')))
	to t :  Ecore!EClass (
		name <- s.name,
		instanceClassName <- s.instanceClassName,
		instanceTypeName <- s.instanceTypeName,
		"abstract" <- s."abstract",
		interface <- s.interface,
		eAnnotations <- s.eAnnotations,
		eTypeParameters <- s.eTypeParameters,
		eSuperTypes <- s.eSuperTypes,
		eOperations <- s.eOperations,
		eStructuralFeatures <- s.eStructuralFeatures,
		eGenericSuperTypes <- s.eGenericSuperTypes)
}

rule EClass2UEClass {
	from s :Ecore!EClass ((thisModule.inElements->includes(s)) and ((s.eSuperTypes->size()=0)
																or (s."abstract"='false')))
	to t :  Ecore!EClass (
		name <- s.name,
		instanceClassName <- s.instanceClassName,
		instanceTypeName <- s.instanceTypeName,
		"abstract" <- s."abstract",
		interface <- s.interface,
		eAnnotations <- s.eAnnotations,
		eTypeParameters <- s.eTypeParameters,
		eSuperTypes <- s.eSuperTypes->append(thisModule.traceableMetaclass),
		eOperations <- s.eOperations,
		eStructuralFeatures <- s.eStructuralFeatures,
		eGenericSuperTypes <- s.eGenericSuperTypes),
	u :  Ecore!EClass (
		name <- 'U-'+s.name,
  		eReferences <- Sequence{}->append(ref),
		eSuperTypes <- Sequence{}->append(s)
		),
	ref: Ecore!EReference(
		name <- s.name + 's',
		containment <- true,
		lowerBound <- 1,
		upperBound <- -1
		)
}

rule EOperation {
	from s :Ecore!EOperation (thisModule.inElements->includes(s))
 	to t :  Ecore!EOperation (
	 	eType<-s.eType,
		eGenericType<-s.eGenericType,
		name<-s.name,
		eTypeParameters<-s.eTypeParameters
 	)
}

rule EReference {
	from s :Ecore!EReference (thisModule.inElements->includes(s))
 	to t :  Ecore!EReference (
		name <- s.name,
		ordered <- s.ordered,
		unique <- s.unique,
		lowerBound <- 0,
		upperBound <- s.upperBound,
		changeable <- s.changeable,
		volatile <- s.volatile,
		transient <- s.transient,
		defaultValueLiteral <- s.defaultValueLiteral,
		unsettable <- s.unsettable,
		"derived" <- s."derived",
		containment <- s.containment,
		resolveProxies <- s.resolveProxies,
		eAnnotations <- s.eAnnotations,
		eType <- s.eType,
		eGenericType <- s.eGenericType,
		eOpposite <- s.eOpposite,
		eKeys <- s.eKeys)
}

rule EAttribute {
	from s : Ecore!EAttribute (thisModule.inElements->includes(s))
	to t :  Ecore!EAttribute (
		 name <- s.name,
		 ordered <- s.ordered,
		 unique <- s.unique,
		 lowerBound <- 0,
		 upperBound <- s.upperBound,
		 changeable <- s.changeable,
		 volatile <- s.volatile,
		 transient <- s.transient,
		 defaultValueLiteral <- s.defaultValueLiteral,
		 unsettable <- s.unsettable,
		 "derived" <- s."derived",
		 iD <- s.iD,
		 eAnnotations <- s.eAnnotations,
		 eType <- s.eType,
		 eGenericType <- s.eGenericType)
}

rule EDataType {
	from s : Ecore!EDataType (
		if thisModule.inElements->includes(s) then
 			s.oclIsTypeOf(INMODEL!EDataType)
		else 
			false 
		endif)
	to t : OUTMODEL!EDataType (
		name <- s.name,
		instanceClassName <- s.instanceClassName,
		instanceTypeName <- s.instanceTypeName,
		serializable <- s.serializable,
		eAnnotations <- s.eAnnotations,
		eTypeParameters <- s.eTypeParameters)
}
  
rule EEnum {
	from s : Ecore!EEnum (thisModule.inElements->includes(s))
 	to t :  Ecore!EEnum (
		name <- s.name,
		instanceClassName <- s.instanceClassName,
		instanceTypeName <- s.instanceTypeName,
		serializable <- s.serializable,
		eAnnotations <- s.eAnnotations,
		eTypeParameters <- s.eTypeParameters,
		eLiterals <- s.eLiterals)
}

rule EEnumLiteral {
	from s : Ecore!EEnumLiteral (thisModule.inElements->includes(s))
	to t :  Ecore!EEnumLiteral (
		name <- s.name,
		value <- s.value,
		instance <- s.instance,
		literal <- s.literal,
		eAnnotations <- s.eAnnotations)
}

rule EAnnotation {
	from s : Ecore!EAnnotation (thisModule.inElements->includes(s))
 	to t :  Ecore!EAnnotation (
		source <- s.source,
		eAnnotations <- s.eAnnotations,
		details <- s.details,
		contents <- s.contents,
		references <- s.references)
}
