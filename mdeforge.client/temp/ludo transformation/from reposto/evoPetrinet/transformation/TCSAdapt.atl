-- @atlcompiler atl2006
-- Generated by: $Id$
module EModelCopy;

create OUT : OUTMODEL from IN : INMODEL, IN_Diff : EcoreDiff, MMsource: ecore;


endpoint rule saveLog(){
	

	do{
		'=============================='.println();
		'Saving log in folder /adapted/log.txt...'.println();
		thisModule.LOGString<-thisModule.LOGString+'End log...\n';
		thisModule.LOGString.toString().writeTo('/evoPetrinet/Syntax/adapted/log.txt');
	}
}
entrypoint rule initLog(){
	

	do{
		'=============================='.println();
		'Initialize log...'.println();
		thisModule.LOGString<-'Log for TCS syntax adaptation...\n';
	}
}

rule appendLog(s: String){
	do{
		s.println();
		thisModule.LOGString<-thisModule.LOGString+s+'\n';
	}
}
--helper def : inElements : Set(INMODEL!"ecore::EObject") = INMODEL!"ecore::EObject".allInstancesFrom('IN');
helper def: concreteSyntax: OUTMODEL!ConcreteSyntax =OUTMODEL!ConcreteSyntax ;

helper def: assoMap: Map(MMsource!Reference, Sequence(MMsource!Reference))=Map{};

helper  def: searchKey(key:String):OUTMODEL!Literal=
	if((OUTMODEL!Symbol).allInstancesFrom('IN')->select(e| e.value=key)->first().oclIsUndefined())then
	if(OUTMODEL!Literal).allInstancesFrom('IN')->select(e| e.value=key)->first().oclIsUndefined()
	then
	OclUndefined
	else
		(OUTMODEL!Literal).allInstances()->select(e| e.value=key)->first()
		endif
		else
			(OUTMODEL!Symbol).allInstances()->select(e| e.value=key)->first()
			endif
	;


rule isAlreadyConsidered(ref1 : MMsource!Reference, ref2 : MMsource!Reference) {

	do {
		if (not thisModule.assoMap.get(ref2).oclIsUndefined()) {
			if (thisModule.assoMap.get(ref2)->includes(ref1)) {
				true;
			}
			else {
			    if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
			}
		}
		else  {
				if (not thisModule.assoMap.get(ref1).oclIsUndefined()) {
					thisModule.assoMap <- thisModule.assoMap.including(ref1,thisModule.assoMap.get(ref1)->including(ref2));
					false;
			    }
				else {	
					thisModule.assoMap <- thisModule.assoMap.including(ref1, Sequence{ref2});
					false;
				}
		}
		
	}
}
--helper context EcoreDiff!AddedEClass def: preProcessSubClassTemplate(): String=
--	for(e in self.eStructuralFeatures->select(e|e.upperBound=1 and e.lowerBound=1){
--		
--	}
--	;
	
helper context EcoreDiff!AddedEClass def: isSuperClass(): Boolean=
	EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(g|g.oclIsKindOf(EcoreDiff!EClass))->exists(e|e.eSuperTypes->includes(self))
	;

helper context EcoreDiff!EClass def: eAllFeatures(): Sequence(EcoreDiff!EStructuralFeatures)=
	self.eAllNotMandatoryFeatures().union(self.eAllMandatoryFeatures())
	;
helper context EcoreDiff!EClass def: eAllNotMandatoryFeatures(): Sequence(EcoreDiff!EStructuralFeatures)=
	
	self.eSuperTypes->iterate(c; seq :Sequence(EcoreDiff!EStructuralFeatures)= self.eStructuralFeatures->select(e|e.upperBound<>1 and e.lowerBound<>1) |
	seq.union(c.eAllNotMandatoryFeatures())
	)

	;
helper context EcoreDiff!EClass def: eAllMandatoryFeatures(): Sequence(EcoreDiff!EStructuralFeatures)=
	
	self.eSuperTypes->iterate(c; seq :Sequence(EcoreDiff!EStructuralFeatures)= self.eStructuralFeatures->select(e|e.upperBound=1 and e.lowerBound=1) |
	seq.union(c.eAllMandatoryFeatures())
	)
;


helper context EcoreDiff!AddedEClass def: eAllSuperTypes(): Sequence(EcoreDiff!EClass)=
	self.eSuperTypes->iterate(c; seq :Sequence(EcoreDiff!EClass)= self.eSuperTypes |
	seq.union(c.eAllSuperTypes())
	)
	;


helper context INMODEL!ClassTemplate  def: getAffectedElement():EcoreDiff!DifferenceElement =
	if(EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e|e.oclIsTypeOf(EcoreDiff!ChangedEClass) or e.oclIsTypeOf(EcoreDiff!DeletedEClass)  and e.name=self.name )->notEmpty())then
EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e|e.oclIsTypeOf(EcoreDiff!ChangedEClass) or e.oclIsTypeOf(EcoreDiff!DeletedEClass)  and e.name=self.name )->first()
	else
	OclUndefined
		endif
	
	;


helper context INMODEL!ClassTemplate  def: getChangedElement():EcoreDiff!DifferenceElement =
	if(EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e|e.oclIsTypeOf(EcoreDiff!ChangedEClass)  and e.name=self.name )->notEmpty())then
EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e|e.oclIsTypeOf(EcoreDiff!ChangedEClass)  and e.name=self.name )->first()
	else
	OclUndefined
		endif
	
	;
helper context INMODEL!ClassTemplate  def: isAffectedElement():Boolean =
	if(EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e|e.oclIsTypeOf(EcoreDiff!ChangedEClass) or e.oclIsTypeOf(EcoreDiff!DeletedEClass)  and e.name=self.name )->notEmpty())then
true
	else
	false
		endif
	
	;

helper context INMODEL!ClassTemplate  def: isChangedElement():Boolean =
	if(EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e|e.oclIsTypeOf(EcoreDiff!ChangedEClass)  and e.name=self.name )->notEmpty())then
true
	else
	false
		endif
	
	;


--helper context INMODEL!ClassTemplate  def: isRefToClass():Boolean =
--	if(EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e|e.oclIsTypeOf(EcoreDiff!ChangedEReference)  and e.name=self.name and ( EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(g|g.oclIsTypeOf(EcoreDiff!AddedEClass) and g.name=e.updatedElement->first().name and g.structuralFeatures->exists(a|a.oclIsTypeOf(EcoreDiff!EReference) and a.name=e.name))->notEmpty())then
--true
--	else
--	false
--		endif
--	
--	;


helper context  INMODEL!ClassTemplate def: preProcess(): String =
if self.getAffectedElement().oclIsUndefined() then 'undefined' else self.getAffectedElement().updatedElement->first().name.toString() endif
	;
----------------------------------Property------------------------------------------
helper context INMODEL!Property  def: isMovedOut():Boolean =
	if(EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e|e.oclIsTypeOf(EcoreDiff!ChangedEReference) or e.oclIsTypeOf(EcoreDiff!ChangedEAttribute)  and e.name=self.name )->notEmpty())then
EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e|e.oclIsTypeOf(EcoreDiff!ChangedEReference) or e.oclIsTypeOf(EcoreDiff!ChangedEAttribute)  and e.name=self.name )->first()
	else
	OclUndefined
		endif
	
	;

helper context INMODEL!Property  def: getAffectedElement():EcoreDiff!DifferenceElement =
	if((EcoreDiff!ChangedEReference.allInstancesFrom('IN_Diff').union(EcoreDiff!ChangedEReference.allInstancesFrom('IN_Diff')).union(EcoreDiff!ChangedEClass.allInstancesFrom('IN_Diff'))->select(e|e.applicationElement.name=self.name )->notEmpty()))then
EcoreDiff!ChangedEReference.allInstancesFrom('IN_Diff').union(EcoreDiff!ChangedEReference.allInstancesFrom('IN_Diff'))->select(e|e.applicationElement.name=self.name )->first()
	else
	OclUndefined
		endif
	
	;


helper context INMODEL!Property  def: getChangedElement():EcoreDiff!DifferenceElement =
	if(EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e| e.oclIsTypeOf(EcoreDiff!ChangedEReference) or e.oclIsTypeOf(EcoreDiff!ChangedEAttribute))->select( g|g.applicationElement.name=self.name )->notEmpty())then
EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e| e.oclIsTypeOf(EcoreDiff!ChangedEReference) or e.oclIsTypeOf(EcoreDiff!ChangedEAttribute) )->select( g|g.applicationElement.name=self.name )->first()
	else
	OclUndefined
		endif
	
	;
helper context INMODEL!Property  def: isAffectedElement():Boolean =
	if (not self.getElementFromMMsource().oclIsUndefined())then
	self.getElementFromMMsource().isAffected()
		else
	false
endif
	
	;
helper context INMODEL!Property  def: isMovedOutElement():Boolean =
	if (not self.getElementFromMMsource().oclIsUndefined())then
	self.getElementFromMMsource().isMovedOut()
		else
	false
endif
	
	;

helper context INMODEL!Property  def: isRefToClassElement():Boolean =
	if (not self.getElementFromMMsource().oclIsUndefined())then
	self.getElementFromMMsource().isRefToClass()
		else
	false
endif
	
	;
helper context  INMODEL!Property  def: isTypeAdded(added:EcoreDiff!AddedEClass):Boolean =
if(not self.getChangedElement().oclIsUndefined())then
	if(	added= self.getChangedElement().updatedElement->first().eType)then true
else false
endif
else false
endif
	;


helper context INMODEL!Property  def: isChangedElement():Boolean =
	if(EcoreDiff!DifferenceElement.allInstancesFrom('IN_Diff')->select(e|e.oclIsTypeOf(EcoreDiff!ChangedEReference) or e.oclIsTypeOf(EcoreDiff!ChangedEAttribute)  and e.name=self.name )->notEmpty())then
true
	else
	false
		endif
	
	;
helper context INMODEL!Property  def: isMergedElement():Boolean =
if (not self.getElementFromMMsource().oclIsUndefined())then
	self.getElementFromMMsource().isMerged()
		else
	false
endif
	;

helper context  INMODEL!Property def: preProcess(): String =
if self.getAffectedElement().oclIsUndefined() then 'undefined' else self.getAffectedElement().updatedElement->first().name.toString() endif
;
helper context  INMODEL!Property def: preProcessArgs( args:Sequence(INMODEL!PropertyArg)): Sequence(INMODEL!PropertyArg) =
args->select(e|not e.oclIsTypeOf(INMODEL!RefersToPArg))

;

-----ecore helpers -----------------
helper context ecore!EReference def: isRefToClass():Boolean=
	EcoreDiff!ChangedEReference.allInstancesFrom('IN_Diff')->exists(e| e.applicationElement=self   and  EcoreDiff!AddedEClass.allInstancesFrom('IN_Diff')->exists(g|g.name=(e.updatedElement->first().eType.name) and g.eStructuralFeatures->select(s|s.name=self.name)->exists(k|k.eType.name=self.eType.name)) )-- and e.eType.name=self.eType.name)
	;

helper context ecore!EAttribute def: isRefToClass():Boolean=
	EcoreDiff!ChangedEAttribute.allInstancesFrom('IN_Diff')->exists(e| e.applicationElement=self   and  EcoreDiff!AddedEClass.allInstancesFrom('IN_Diff')->exists(g|g.name=e.updatedElement->first().eType.name and g.eStructuralFeatures->exists(s|s.name=self.name and s.eType=self.eType)) )-- and e.eType.name=self.eType.name)
	;

helper context ecore!EReference def: isMovedOut():Boolean=
	EcoreDiff!ChangedEReference.allInstancesFrom('IN_Diff')->exists(e| e.applicationElement=self   and e.eContainer().applicationElement.name<>self.eContainer().name )-- and e.eType.name=self.eType.name)
	;


helper context ecore!EAttribute def: isMovedOut():Boolean=
	EcoreDiff!ChangedEAttribute.allInstancesFrom('IN_Diff')->exists(e| e.applicationElement=self and e.eContainer().applicationElement.name<>self.eContainer().name)-- and e.eType.name=self.eType.name)
	;


helper context ecore!EReference def: isMerged(): Boolean=	
	
	EcoreDiff!ChangedEReference.allInstancesFrom('IN_Diff')->exists(e|e.applicationElement=self
		
	and  e.applicationElement.eContainingClass.name=self.eContainingClass.name
	and  EcoreDiff!ChangedEReference.allInstancesFrom('IN_Diff')->select(g|g.updatedElement=e.updatedElement).size()>1
		
	
	)
	;
helper context ecore!EAttribute def: isMerged(): Boolean=	
	
	EcoreDiff!ChangedEAttribute.allInstancesFrom('IN_Diff')->exists(e|e.applicationElement=self
		
	and  e.applicationElement.eContainingClass.name=self.eContainingClass.name
	and  EcoreDiff!ChangedEAttribute.allInstancesFrom('IN_Diff')->select(g|g.updatedElement=e.updatedElement).size()>1
		
	
	)
	;
helper context ecore!EReference def: isAffected(): Boolean=	
	
	EcoreDiff!ChangedEReference.allInstancesFrom('IN_Diff')->exists(e|e.applicationElement=self
		
	--and  e.applicationElement.eContainingClass.name=self.eContainingClass.name
	
		
	
	)
	;

helper context ecore!EAttribute def: isAffected(): Boolean=	
	
	EcoreDiff!ChangedEAttribute.allInstancesFrom('IN_Diff')->exists(e|e.applicationElement=self
		
	--and  e.applicationElement.eContainingClass.name=self.eContainingClass.name
	
	)
	;
--------------------general helpers----------------------
helper context INMODEL!SequenceElement def: getTemplateContainer(): INMODEL!ClassTemplate=
	
		if not self.elementSequence.templateContainer.oclIsUndefined() then
		self.elementSequence.templateContainer
		else
			self.elementSequence.blockContainer.blockSequence.eContainer().elementSequence.templateContainer
			endif
	
	;

helper context INMODEL!Property def: getElementFromMMsource():ecore!NamedElement=

	if (ecore!EAttribute.allInstancesFrom('MMsource').union(ecore!EReference.allInstancesFrom('MMsource'))->exists(e|e.name=self.name and (self.getTemplateContainer().name=e.eContainer().name or e.eContainer().isSupertype(self.getTemplateContainer().name)) ))then
	ecore!EAttribute.allInstancesFrom('MMsource').union(ecore!EReference.allInstancesFrom('MMsource'))->select(e|e.name=self.name and (self.getTemplateContainer().name=e.eContainer().name or e.eContainer().isSupertype(self.getTemplateContainer().name)) )->first()
	else
		OclUndefined
		endif

	;
helper context ecore!EClass def:getSuperTypesClasses(): Sequence(ecore!EClass) =
	self.eSuperTypes
	;

helper context ecore!EClass def:isSupertype(subtype:String): Boolean =
	if(not ecore!EClass.allInstancesFrom('MMsource')->select(e|e.name=subtype).isEmpty())then
	if(ecore!EClass.allInstancesFrom('MMsource')->select(e|e.name=subtype)->first().eSuperTypes->collect(g|g.name)->includes(self.name))
		then true
	else
		false
	
		endif
		else false
		endif
	;

helper context INMODEL!ClassTemplate def: getElementFromMMsource():ecore!NamedElement=

	if (ecore!EClass.allInstancesFrom('MMsource')->exists(e|e.name=self.name and self.model.namee.eContainer().name))then
	ecore!EClass.allInstancesFrom('MMsource')->select(e|e.name=self.name  and self.model.name=e.eContainer().name)->first()
	else
		OclUndefined
		endif

	;

helper context INMODEL!Property def: getContainer(): INMODEL!NamedElement =
	if(self.elementSequence.templateContainer.oclIsUndefined())then 
	self.elementSequence.blockContainer.elementSequence.templateContainer
	else
		self.elementSequence.templateContainer
		endif
	;
helper context OUTMODEL!"Sequence" def: getContainer(): OUTMODEL!NamedElement =
		if(self.templateContainer.oclIsUndefined())then 
	self.blockContainer.elementSequence.templateContainer
	else
		self.templateContainer
		endif
	;
----------------------------------------------------------
rule ConcreteSyntax {
 from s : INMODEL!ConcreteSyntax
 to t : OUTMODEL!ConcreteSyntax (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 k <- s.k,
 lexer <- s.lexer,
 templates <- s.templates,
 keywords <- s.keywords,
 symbols <- s.symbols,
 operatorLists <- s.operatorLists,
 tokens <- s.tokens)
 do{
 	thisModule.concreteSyntax<-s;
 	thisModule.appendLog('Adaptation for concrete syntax '+s.name);
 }
}

rule FunctionTemplate {
 from s : INMODEL!FunctionTemplate
 to t : OUTMODEL!FunctionTemplate (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 disambiguate <- s.disambiguate,
 disambiguateV3 <- s.disambiguateV3,
 className <- s.className,
 functionSequence <- s.functionSequence)
}


-------------------------------------------------------------
--conservative copy of Class Template
rule ClassTemplate {
 from s : INMODEL!ClassTemplate(not s.isAffectedElement())
 to t : OUTMODEL!ClassTemplate (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 disambiguate <- s.disambiguate,
 disambiguateV3 <- s.disambiguateV3,
 modifiers <- s.modifiers,
 isAbstract <- s.isAbstract,
 isDeep <- s.isDeep,
 isOperatored <- s.isOperatored,
 isMain <- s.isMain,
 isMulti <- s.isMulti,
 isContext <- s.isContext,
 isAddToContext <- s.isAddToContext,
 isNonPrimary <- s.isNonPrimary,
 mode <- s.mode,
 templateSequence <- s.templateSequence,
 prefixSequence <- s.prefixSequence,
 operatorList <- s.operatorList,
 parentheses <- s.parentheses)do{
 	
 }
}
---------changed Class Template---------------------------
rule ClassTemplateChanged {
 from s : INMODEL!ClassTemplate(s.isAffectedElement() and s.isChangedElement())
 to t : OUTMODEL!ClassTemplate (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.preProcess(),
 disambiguate <- s.disambiguate,
 disambiguateV3 <- s.disambiguateV3,
 modifiers <- s.modifiers,
 isAbstract <- s.isAbstract,
 isDeep <- s.isDeep,
 isOperatored <- s.isOperatored,
 isMain <- s.isMain,
 isMulti <- s.isMulti,
 isContext <- s.isContext,
 isAddToContext <- s.isAddToContext,
 isNonPrimary <- s.isNonPrimary,
 mode <- s.mode,
 templateSequence <- s.templateSequence,
 prefixSequence <- s.prefixSequence,
 operatorList <- s.operatorList,
 parentheses <- s.parentheses)
 do{
 	thisModule.appendLog('Class Template '+s.name+' has been changed and adapted to '+s.preProcess());
 }
}

-------------added template for superclasses------------------
rule ClassTemplateAddedSuperClasses {
 from s : EcoreDiff!AddedEClass(s.isSuperClass())
 to t : OUTMODEL!ClassTemplate (
 concreteSyntax<-thisModule.concreteSyntax,
 name <- s.name,

 isAbstract <- true)
 do{
	thisModule.appendLog('Class Template '+s.name+' has been added like abstract ClassTemplate since '+s.name+' is superclass');
 }
}

--rule ClassTemplateAddedSubClasses {
-- from s : EcoreDiff!AddedEClass(not s.isSuperClass())
-- to t : OUTMODEL!ClassTemplate (
-- concreteSyntax<-thisModule.concreteSyntax,
-- name <- s.name
-- 
-- ),
--
-- key: OUTMODEL!Keyword(
-- value<-s.name
-- 
-- ),
-- 
--  seq : OUTMODEL!"Sequence" (
-- elements <- elements,
-- templateContainer<-t
--  ),
-- 
-- elements: OUTMODEL!LiteralRef(
-- referredLiteral<-key,
-- elementSequence<-seq
-- ),
-- property:distinct OUTMODEL!Property foreach(e in s.eStructuralFeatures->select(e|e.upperBound=1 and e.lowerBound=1))(
-- name<-e.name.debug('ciao')	,
--  elementSequence<-seq
-- )
 
 
 
--,
--features : distinct OUTMODEL!Property foreach(e in s.eStructuralFeatures)(
--		name<-e.name,
--		elementSequence<-seq,
--		propertyArgs<-thisModule.createNameRef(s)
--		
--	)
	--do{
	--s.allSuperTypesFeature().toString().println();

--		for(e in s.eStructuralFeatures){
--			
--			thisModule.createFeature(e,s,seq);
--			thisModule.createProperty(e.name,s,seq);
--			
--		}
--	}
 --
--}

  
 

 
lazy rule createKey {
   from
     i: EcoreDiff!EStructuralFeature
   to 
  args: OUTMODEL!Keyword (

 value <- i.name)
 }

 rule createSymbol(symbol:String) {
  
   to 
  args: OUTMODEL!Symbol (

 value <- symbol)
 do{
 	args;
 }
 }


 
rule createRefArg(ref:String) {
   
  
to 
  args: OUTMODEL!RefersToPArg (

 propertyName <- ref)

 do{
 	args;
 }
 }

-------------------------------------------------------------
rule Parentheses {
 from s : INMODEL!Parentheses
 to t : OUTMODEL!Parentheses (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 isOff <- s.isOff,
 left <- s.left,
 right <- s.right)
}

rule PrimitiveTemplate {
 from s : INMODEL!PrimitiveTemplate
 to t : OUTMODEL!PrimitiveTemplate (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 disambiguate <- s.disambiguate,
 disambiguateV3 <- s.disambiguateV3,
 typeName <- s.typeName,
 isDefault <- s.isDefault,
 tokenName <- s.tokenName,
 value <- s.value,
 serializer <- s.serializer,
 orKeyword <- s.orKeyword)
}

rule OperatorTemplate {
 from s : INMODEL!OperatorTemplate
 to t : OUTMODEL!OperatorTemplate (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 disambiguate <- s.disambiguate,
 disambiguateV3 <- s.disambiguateV3,
 source <- s.source,
 storeOpTo <- s.storeOpTo,
 storeRightTo <- s.storeRightTo,
 isContext <- s.isContext,
 operators <- s.operators,
 otSequence <- s.otSequence)
}

rule EnumerationTemplate {
 from s : INMODEL!EnumerationTemplate
 to t : OUTMODEL!EnumerationTemplate (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 disambiguate <- s.disambiguate,
 disambiguateV3 <- s.disambiguateV3,
 automatic <- s.automatic,
 mappings <- s.mappings)
}

rule EnumLiteralMapping {
 from s : INMODEL!EnumLiteralMapping
 to t : OUTMODEL!EnumLiteralMapping (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 literal <- s.literal,
 element <- s.element)
}

rule Symbol {
 from s : INMODEL!Symbol
 to t : OUTMODEL!Symbol (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 value <- s.value,
 spaces <- s.spaces,
 operators <- s.operators,
 literalRefs <- s.literalRefs)
}

rule Keyword {
 from s : INMODEL!Keyword
 to t : OUTMODEL!Keyword (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 value <- s.value,
 operators <- s.operators,
 literalRefs <- s.literalRefs)
}

rule OperatorList {
 from s : INMODEL!OperatorList
 to t : OUTMODEL!OperatorList (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 priorities <- s.priorities)
}

rule Priority {
 from s : INMODEL!Priority
 to t : OUTMODEL!Priority (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 value <- s.value,
 associativity <- s.associativity,
 operators <- s.operators)
}

rule Operator {
 from s : INMODEL!Operator
 to t : OUTMODEL!Operator (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 isPostfix <- s.isPostfix,
 arity <- s.arity,
 literal <- s.literal,
 templates <- s.templates)
}

rule "Sequence" {
 from s : INMODEL!"Sequence" (not s.elements->select(a|a.oclIsTypeOf(INMODEL!Property))->exists(r| r.isMergedElement() ))
 to t : OUTMODEL!"Sequence" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 elements <- s.elements)
}

rule LiteralRef {
 from s : INMODEL!LiteralRef
 to t : OUTMODEL!LiteralRef (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 referredLiteral <- s.referredLiteral)
 do{
 	
 }
}
--------------------------------
rule Property {
 from s : INMODEL!Property
 (
 	  not s.isAffectedElement()
 )
 to t : OUTMODEL!Property (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 propertyArgs <- s.propertyArgs)
 do{
 			
 }
}

rule Property_Changed {
 from s : INMODEL!Property(s.isAffectedElement() and s.isChangedElement() and not s.isMergedElement())
 to t : OUTMODEL!Property (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <-s.preProcess(),
 propertyArgs <- s.propertyArgs)
 do{
 	thisModule.appendLog('Property '+s.name+' in Template '+s.getContainer().name+' has been changed and adapted to '+s.preProcess());	
 }
}


rule Property_Merged {
 from
 s : INMODEL!Property ,
  s1 : INMODEL!Property
 ( s.isMergedElement() and s1.isMergedElement() and  s.name<>s1.name and not thisModule.isAlreadyConsidered(s.getElementFromMMsource(), s1.getElementFromMMsource())
  	)
to
  container : OUTMODEL!"Sequence" (
 location <- s.elementSequence.location,
 commentsBefore <- s.elementSequence.commentsBefore,
 commentsAfter <- s.elementSequence.commentsAfter,
 elements <- s.elementSequence.elements,
 blockContainer<-s.elementSequence.blockContainer,
 templateContainer<-s.elementSequence.templateContainer
 ),
t : OUTMODEL!Property (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <-s.preProcess(),
 propertyArgs <- s.propertyArgs,
 elementSequence<-container
 )
 do{
-- container.blockContainer<-	s.elementSequence.blockContainer;
 thisModule.appendLog('Properties '+s.name+' and '+s1.name+' in Template '+s.getContainer().name+' has been merged to '+s.preProcess());	

 }
}


rule Property_refToClass {
 from s : INMODEL!Property
 ,
 added: EcoreDiff!AddedEClass
 (
	s.isTypeAdded(added)
	and
	s.isRefToClassElement()
	
)
to
 p : OUTMODEL!Property (
 	location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <-s.preProcess(),
 propertyArgs <- s.propertyArgs,
 elementSequence<-litANDP

 )
 ,
 template : OUTMODEL!ClassTemplate (
 concreteSyntax<-thisModule.concreteSyntax,
 name <- added.name,
 isAddToContext<-true
 )
 ,
 key: OUTMODEL!Keyword(
 value<-added.name
 )
 , seq : OUTMODEL!"Sequence" (
 elements <- elements,
 templateContainer<-template
  )
  , 
 elements: OUTMODEL!LiteralRef(
 referredLiteral<-key,
 elementSequence<-seq
 )
 ,
 cond:OUTMODEL!ConditionalElement(
	elementSequence<-thisModule.resolveTemp(s.elementSequence,'t'),
	condition<-condition,
	thenSequence<-litANDP
	),
	
	litANDP:OUTMODEL!"Sequence"(
	elements<-Sequence{p}		
	),
	condition:OUTMODEL!AndExp(
	expressions<-isdef	
	),
	isdef: OUTMODEL!IsDefinedExp(
	propertyName<-	s.preProcess()
	)
	
	
 do{
	thisModule.appendLog('Property '+s.name+' has been replaced with '+added.name+' reference named '+s.preProcess()+' in Template '+s.getContainer().name);	
 	
	
 	

for(e in added.eAllMandatoryFeatures()->select(e|e.oclIsKindOf(EcoreDiff!EAttribute))){
			--attributes
			
			thisModule.getALiteral(e,seq);
			thisModule.getAProperty(e,seq);
			
		}
for(e in added.eAllMandatoryFeatures()->select(e|e.oclIsKindOf(EcoreDiff!EReference))->select(g| g.eOpposite.oclIsUndefined())){
			--references
		
			thisModule.getRLiteral(e,seq);
		thisModule.getRProperty(e,seq);
	
		}
for(e in added.eAllNotMandatoryFeatures()->select(e|e.oclIsKindOf(EcoreDiff!EAttribute))){
			
			
			
			thisModule.getAPropertyNotMandatory(e,seq,thisModule.getALiteral(e,seq));
			
		}
for(e in added.eAllNotMandatoryFeatures()->select(e|e.oclIsKindOf(EcoreDiff!EReference))->select(g| g.eOpposite.oclIsUndefined())){
		
			thisModule.getRPropertyNotMandatory(e,seq,	thisModule.getRLiteral(e,seq));
			
		}
	thisModule.createLiteral(thisModule.searchKey(';'),seq);
 }
}


lazy rule getALiteral{
	from e:EcoreDiff!AddedEAttribute,
	seq:INMODEL!"Sequence"
	to t:OUTMODEL!LiteralRef(
		referredLiteral<-thisModule.createKey(e),
		elementSequence<-seq
	)do{
		--(e.name.toString()+':'+e.oclType().toString()).toString().println();
	}
}
lazy rule getRLiteral{
	from e:EcoreDiff!AddedEReference,
	seq:INMODEL!"Sequence"
	to t1:OUTMODEL!LiteralRef(
		referredLiteral<-thisModule.createKey(e),
		elementSequence<-seq
	)do{
		--(e.name.toString()+':'+e.oclType().toString()).toString().println();
	}
}
lazy rule getAProperty{
	from e:EcoreDiff!AddedEAttribute,
	seq:INMODEL!"Sequence"
	
	to p: OUTMODEL!Property(
		name<-e.name,
		elementSequence<-seq
		--,propertyArgs<-thisModule.createRefArg(refName)
	
	)
}
lazy rule getAPropertyNotMandatory{
	from e:EcoreDiff!AddedEAttribute,
	seq:INMODEL!"Sequence",
	lit:INMODEL!LiteralRef
	to p: OUTMODEL!Property(
		name<-e.name,
		elementSequence<-seq
		--,propertyArgs<-thisModule.createRefArg(refName)
	
	)
	,
	cond:OUTMODEL!ConditionalElement(
	elementSequence<-seq,
	condition<-condition,
	thenSequence<-litANDP
	),
	litANDP:OUTMODEL!"Sequence"(
	elements<-Sequence{lit,p}		
	),
	condition:OUTMODEL!AndExp(
	expressions<-isdef	
	),
	isdef: OUTMODEL!IsDefinedExp(
	propertyName<-	e.name
	)
}

lazy rule getRProperty{
	from ea:EcoreDiff!AddedEReference,
	seqa:INMODEL!"Sequence"
	to p1: OUTMODEL!Property(
		name<-ea.name,
		elementSequence<-seqa
		,propertyArgs<-thisModule.createRefArg('type reference name here...')
	
	)do{
		thisModule.appendLog('Added '+ea.name+' in Template '+seqa.getContainer().name+'...please provide reference name');	
		
	}
}
lazy rule getRPropertyNotMandatory{
	from ea:EcoreDiff!AddedEReference,
	seqa:INMODEL!"Sequence",
	lit:INMODEL!LiteralRef
	to p1: OUTMODEL!Property(
		name<-ea.name,
		elementSequence<-seqa
		,propertyArgs<-
		thisModule.getRefArg(ea,seqa)
		--thisModule.getOptionality(ea,seqa)
	
	),
	cond:OUTMODEL!ConditionalElement(
	elementSequence<-seqa,
	condition<-condition,
	thenSequence<-litANDP
	),
	litANDP:OUTMODEL!"Sequence"(
	elements<-Sequence{lit,p1}		
	)
	,
	condition:OUTMODEL!AndExp(
	expressions<-isdef	
	),
	isdef: OUTMODEL!IsDefinedExp(
	propertyName<-	ea.name
	)
}
lazy rule getRefArg{
from ea:EcoreDiff!AddedEReference,
	seqa:INMODEL!"Sequence"
	to 
  args: OUTMODEL!RefersToPArg (

 propertyName <- 'type your reference name here...')
	 do{
	 	thisModule.appendLog('Added '+ea.name+' in Template '+seqa.getContainer().name+'...please provide reference name');	
		
	 }
}
 lazy rule getOptionality{
	from ea:EcoreDiff!AddedEReference,
	seq:INMODEL!"Sequence"
	
	to 
	cond:OUTMODEL!ConditionalElement(
	condition<-condition,
	thenSequence<-seq
	)
	,
	condition:OUTMODEL!AndExp(
	expressions<-isdef	
	),
	isdef: OUTMODEL!IsDefinedExp(
	propertyName<-	ea.name
	)
do
	{
		
	}
}
 rule createLiteral(symbol:String,seq:INMODEL!"Sequence"){
 	to t: OUTMODEL!LiteralRef(
 	referredLiteral<-symbol	,
	elementSequence<-seq
 	)do{
 		t;
 	}
 }
--------------------------------
rule CustomSeparator {
 from s : INMODEL!CustomSeparator
 to t : OUTMODEL!CustomSeparator (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name)
}

rule Block {
 from s : INMODEL!Block
 to t : OUTMODEL!Block (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 blockSequence <- s.blockSequence,
 blockArgs <- s.blockArgs)
}

rule ConditionalElement {
 from s : INMODEL!ConditionalElement
 to t : OUTMODEL!ConditionalElement (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 condition <- s.condition,
 thenSequence <- s.thenSequence,
 elseSequence <- s.elseSequence)
}

rule PropertyInit {
 from s : INMODEL!PropertyInit
 to t : OUTMODEL!PropertyInit (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 value <- s.value)
}

rule Alternative {
 from s : INMODEL!Alternative
 to t : OUTMODEL!Alternative (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 isMulti <- s.isMulti,
 sequences <- s.sequences)
}

rule FunctionCall {
 from s : INMODEL!FunctionCall
 to t : OUTMODEL!FunctionCall (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 calledFunction <- s.calledFunction)
}

rule RefersToPArg {
 from s : INMODEL!RefersToPArg
 to t : OUTMODEL!RefersToPArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName)
}

rule LookInPArg {
 from s : INMODEL!LookInPArg
 to t : OUTMODEL!LookInPArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName)
}

rule CreateInPArg {
 from s : INMODEL!CreateInPArg
 to t : OUTMODEL!CreateInPArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName)
}

rule RefersToKeyPArg {
 from s : INMODEL!RefersToKeyPArg
 to t : OUTMODEL!RefersToKeyPArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 value <- s.value)
}

rule SeparatorPArg {
 from s : INMODEL!SeparatorPArg
 to t : OUTMODEL!SeparatorPArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 separatorSequence <- s.separatorSequence)
}

rule AutoCreatePArg {
 from s : INMODEL!AutoCreatePArg
 to t : OUTMODEL!AutoCreatePArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 value <- s.value)
}

rule ImportContextPArg {
 from s : INMODEL!ImportContextPArg
 to t : OUTMODEL!ImportContextPArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter)
}

rule ForcedLowerPArg {
 from s : INMODEL!ForcedLowerPArg
 to t : OUTMODEL!ForcedLowerPArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 value <- s.value)
}

rule CreateAsPArg {
 from s : INMODEL!CreateAsPArg
 to t : OUTMODEL!CreateAsPArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name)
}

rule AsPArg {
 from s : INMODEL!AsPArg
 to t : OUTMODEL!AsPArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 value <- s.value)
}

rule ModePArg {
 from s : INMODEL!ModePArg
 to t : OUTMODEL!ModePArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 mode <- s.mode)
}

rule NbNLBArg {
 from s : INMODEL!NbNLBArg
 to t : OUTMODEL!NbNLBArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 value <- s.value)
}

rule IndentIncrBArg {
 from s : INMODEL!IndentIncrBArg
 to t : OUTMODEL!IndentIncrBArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 value <- s.value)
}

rule StartNLBArg {
 from s : INMODEL!StartNLBArg
 to t : OUTMODEL!StartNLBArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 value <- s.value)
}

rule StartNbNLBArg {
 from s : INMODEL!StartNbNLBArg
 to t : OUTMODEL!StartNbNLBArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 value <- s.value)
}

rule EndNLBArg {
 from s : INMODEL!EndNLBArg
 to t : OUTMODEL!EndNLBArg (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 value <- s.value)
}

rule AndExp {
 from s : INMODEL!AndExp
 to t : OUTMODEL!AndExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 expressions <- s.expressions)
}

rule EqualsExp {
 from s : INMODEL!EqualsExp
 to t : OUTMODEL!EqualsExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName,
 value <- s.value)
}

rule BooleanPropertyExp {
 from s : INMODEL!BooleanPropertyExp
 to t : OUTMODEL!BooleanPropertyExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName)
}

rule IsDefinedExp {
 from s : INMODEL!IsDefinedExp
 to t : OUTMODEL!IsDefinedExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName)
}

rule OneExp {
 from s : INMODEL!OneExp
 to t : OUTMODEL!OneExp (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName)
}

rule StringVal {
 from s : INMODEL!StringVal
 to t : OUTMODEL!StringVal (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 symbol <- s.symbol)
}

rule IntegerVal {
 from s : INMODEL!IntegerVal
 to t : OUTMODEL!IntegerVal (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 symbol <- s.symbol)
}

rule NegativeIntegerVal {
 from s : INMODEL!NegativeIntegerVal
 to t : OUTMODEL!NegativeIntegerVal (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 symbol <- s.symbol)
}

rule EnumLiteralVal {
 from s : INMODEL!EnumLiteralVal
 to t : OUTMODEL!EnumLiteralVal (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name)
}

rule PropertyVal {
 from s : INMODEL!PropertyVal
 to t : OUTMODEL!PropertyVal (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName)
}

rule Token {
 from s : INMODEL!Token
 to t : OUTMODEL!Token (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 pattern <- s.pattern)
}

rule OrPattern {
 from s : INMODEL!OrPattern
 to t : OUTMODEL!OrPattern (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 simplePatterns <- s.simplePatterns)
}

rule RulePattern {
 from s : INMODEL!RulePattern
 to t : OUTMODEL!RulePattern (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 "rule" <- s."rule")
}

rule WordRule {
 from s : INMODEL!WordRule
 to t : OUTMODEL!WordRule (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 start <- s.start,
 part <- s.part,
 end <- s.end,
 words <- s.words)
}

rule Word {
 from s : INMODEL!Word
 to t : OUTMODEL!Word (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 token <- s.token)
}

rule EndOfLineRule {
 from s : INMODEL!EndOfLineRule
 to t : OUTMODEL!EndOfLineRule (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 dropStart <- s.dropStart,
 start <- s.start)
}

rule MultiLineRule {
 from s : INMODEL!MultiLineRule
 to t : OUTMODEL!MultiLineRule (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 dropStart <- s.dropStart,
 dropEnd <- s.dropEnd,
 start <- s.start,
 end <- s.end,
 esc <- s.esc,
 escMappings <- s.escMappings)
}

rule SimpleMapping {
 from s : INMODEL!SimpleMapping
 to t : OUTMODEL!SimpleMapping (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 key <- s.key,
 value <- s.value)
}

rule WildcardMapping {
 from s : INMODEL!WildcardMapping
 to t : OUTMODEL!WildcardMapping (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter)
}

rule OctalMapping {
 from s : INMODEL!OctalMapping
 to t : OUTMODEL!OctalMapping (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter)
}

rule HexadecimalMapping {
 from s : INMODEL!HexadecimalMapping
 to t : OUTMODEL!HexadecimalMapping (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter)
}

rule StringPattern {
 from s : INMODEL!StringPattern
 to t : OUTMODEL!StringPattern (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name)
}

rule ClassPattern {
 from s : INMODEL!ClassPattern
 to t : OUTMODEL!ClassPattern (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name)
}

