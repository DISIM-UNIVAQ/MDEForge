-- @atlcompiler atl2006
module resolvableModelAdaptationsGenerator; -- Module Template
create OUT : ATL  from DELTA : ECOREDIFF;



helper context ECOREDIFF!EClass def : containsMovedInStructuralFeatures() : Boolean = 
	self.eStructuralFeatures->select(e | e.isMovedIn())->notEmpty()
	;

-- Given an AddedClass involved in the ExtractMetaclass modification, this helper returns the class from which the AddedClass has been extracted
helper context ECOREDIFF!AddedEClass def : getExtractingClass() : ECOREDIFF!EClass =
	ECOREDIFF!EStructuralFeature.allInstancesFrom('DELTA')
		->select(e | e.oclIsTypeOf(ECOREDIFF!ChangedEAttribute) or e.oclIsTypeOf(ECOREDIFF!ChangedEReference))
		->select(sf | sf.updatedElement.eContainingClass = self)->first().eContainingClass --TODO Here we assume that the features in an 																					   --Added Class are coming only from one single class
	;

helper context ECOREDIFF!AddedEClass def : extractedStructuralFeatures() : Sequence(ECOREDIFF!EStructuralFeature) =
	self.eStructuralFeatures->select(e | e.isMovedIn())
	;
	
helper context ECOREDIFF!EStructuralFeature def : isMovedIn() : Boolean = 
	ECOREDIFF!EStructuralFeature.allInstancesFrom('DELTA')
		->select(e | e.oclIsTypeOf(ECOREDIFF!ChangedEAttribute) or e.oclIsTypeOf(ECOREDIFF!ChangedEReference))
		->exists(sf | sf.updatedElement = self)
	;

helper context ECOREDIFF!EStructuralFeature def : isMovedOut() : Boolean = 
	if (self.oclIsTypeOf(ECOREDIFF!ChangedEAttribute) or self.oclIsTypeOf(ECOREDIFF!ChangedEReference)) then
		not (self.eContainingClass = self.updatedElement.eContainingClass)
	else
		false
	endif
	;

-- Given an updated element returns its base version element
helper context ECOREDIFF!DifferenceElement def : getBaseVersionElement() : ECOREDIFF!DifferenceElement = 
	ECOREDIFF!DifferenceElement.allInstancesFrom('DELTA')
		-> select ( e | e.oclIsTypeOf(ECOREDIFF!ChangedEAttribute) or e.oclIsTypeOf(ECOREDIFF!ChangedEReference) or e.oclIsTypeOf(ECOREDIFF!ChangedEClass) )
		-> select (f | f.updatedElement = self)
	;
 

helper def : differenceModel :  ECOREDIFF!DifferenceModel = OclUndefined;


rule atlModule {
	from 
 		s: ECOREDIFF!DifferenceModel
		
	to
		t : ATL!Module (
			name <- 'resolvableChangesMigrator',
			outModels <- Sequence {tm},
			inModels <- Sequence {sm},
			isRefining <- false,
			elements<- s.differenceElements,
			commentsBefore <- Set {'-- @atlcompiler atl2006'}						
		),		
		sm : ATL!OclModel (
			name <- 'IN',
			metamodel <- mm1
		),
		tm : ATL!OclModel (
			name <- 'OUT',
			metamodel <- mm2
		),		
		mm1 : ATL!OclModel (
			name <- 'MM1'
		),

		mm2 : ATL!OclModel (
			name <- 'MM2'
		)
	do {
		thisModule.differenceModel <- s;
	}
}




rule ExtractMetaclass {
	from 
		s : ECOREDIFF!AddedEClass (
			s.containsMovedInStructuralFeatures()	
		)
	to  
		matchedRule :  ATL!MatchedRule (
			name<-s.name,
			isAbstract <- false,
			isRefining <- false,
			module<-thisModule.resolveTemp(thisModule.differenceModel,'t'),
			inPattern <- ip,
			outPattern <- op,
			commentsBefore <- Set {'-- This rule applies the ExtractMetaclass evolution'}	
		),
			
		-- Creating the source pattern with a filter enforcing
		-- that matched elements must have the class s for type.
		ip : ATL!InPattern (
			elements <- Sequence {ipe},
			filter <- f
		),
		ipe : ATL!SimpleInPatternElement (
			varName <- 's',
			type <- ipet
		),
		ipet : ATL!OclModelElement (
			name <- s.name,
			model<-thisModule.resolveTemp(thisModule.differenceModel,'mm1')
		),
		f : ATL!OperationCallExp (
			operationName <- 'oclIsTypeOf',
			source <- fv,
			arguments <- Sequence {ft}
		),
		fv : ATL!VariableExp (			
			referredVariable <- ipe
		),
		ft : ATL!OclModelElement (
			name <- s.name,
			model<-thisModule.resolveTemp(thisModule.differenceModel,'mm1')
		),
	
		-- Creating the target pattern.
		op : ATL!OutPattern (
			elements <- Sequence {ope, ope2}
		),
		ope : ATL!SimpleOutPatternElement (
			varName <- 't',
			type <- opet,
			bindings <- s.extractedStructuralFeatures()->collect(e | thisModule.CopyStructuralFeature(e))
		),
		opet : ATL!OclModelElement (
			name <- s.getExtractingClass().name,
			model<-thisModule.resolveTemp(thisModule.differenceModel,'mm2')
		),
		ope2: ATL!SimpleOutPatternElement (
			varName <- 't2',
			type <- opet2,
			bindings <- (
							(s.getExtractingClass().applicationElement.eStructuralFeatures)->asSet() - 
							(s.extractedStructuralFeatures()->collect(e | e.getBaseVersionElement()->first().applicationElement))->asSet()
						)->collect(e | thisModule.CopyStructuralFeature(e))
		),
		opet2 : ATL!OclModelElement (
			name <- s.name,
			model<-thisModule.resolveTemp(thisModule.differenceModel,'mm2')
		)

}


lazy rule CopyStructuralFeature {
	from 
		structuralFeature : ECOREDIFF!EStructuralFeature
	to 
		binding : ATL!Binding (
			propertyName <- structuralFeature.name,
			value <- v
		),
		v : ATL!NavigationOrAttributeCallExp (
			name <- structuralFeature.name,
			source <- src
		),
		src_var : ATL!VariableDeclaration (
			varName <- 's'
		),
		src: ATL!VariableExp (
			referredVariable <- src_var
		)
	do {
		structuralFeature.name.debug('Copying: ');
	}
}




-------------------- Rules for managing unchanged elements --------------------

 

