module ADAPTED_Abc_to_XML;
create OUT : XML from IN : ABC;

helper def: getRoot() : --Warning: element abc has been changed !
ABC!abc =
  --Warning: element abc has been changed !
  ABC!abc.allInstances()->asSequence()->first();

rule ABC2Root {
  from
    s : --Warning: element abc has been changed !
    ABC!abc
  to
    t : XML!Root (
      name <- 'abc',
      children <- Sequence {xmlns, name, --Warning: this element has been merged from others metamodel elements
      s.elements->select(e |
        e.oclIsKindOf(ABC!A)
      ), --Warning: this element has been merged from others metamodel elements
      s.elements->select(e |
        e.oclIsKindOf(ABC!B)
      ), --Warning: this element has been merged from others metamodel elements
      s.elements->select(e |
        e.oclIsKindOf(ABC!C)
      ), s."???dElements???(deleted)"}
    ),
    xmlns : XML!Attribute (
      name <- 'xmlns',
      value <- 'http://abc'
    ),
    name : XML!Attribute (
      name <- 'name',
      value <- 'abc'
    )
}

rule A2Element {
  from
    s : --Warning: element A has been changed !
    ABC!changedA
  to
    t : XML!Element (
      name <- 'a',
      value <- --Warning: this element was moved in a superclass but the navigation element remain the same
      s.type,
      children <- s.bs
    ),
    attr : XML!Attribute (
      name <- 'label',
      value <- --Warning: this element was moved in a superclass but the navigation element remain the same
      s.type,
      parent <- t
    )
}

rule B2Element {
  from
    s : --Warning: element B has been changed !
    ABC!B
  to
    t : XML!Element (
      name <- 'b',
      value <- --Warning: this element was moved in a superclass but the navigation element remain the same
      s.type,
      parent <- thisModule.resolveTemp(s.refA, 't'),
      children <- s."???cs???(top moved out with add opt)"
    ),
    attr : XML!Attribute (
      name <- 'number_of_childrens',
      value <- (--Warning: this element was moved in a superclass but the navigation element remain the same
      s.type.size() + s."???cs???".size() --top moved out and introduced optionality
      ).toString(),
      parent <- t
    ),
    attr_e1 : XML!Attribute (
      name <- 'e1',
      value <- s."???eRef???(deleted)".e1,
      parent <- t
    ),
    attr_e2 : XML!Attribute (
      name <- 'e2',
      value <- s."???eRef???(deleted)".e2,
      parent <- t
    )
}

rule C2Element {
  from
    s : --Warning: element C has been changed !
    ABC!C
  to
    t : XML!Element (
      name <- 'c',
      value <- --Warning: this element was moved in a superclass but the navigation element remain the same
      s.type,
      parent <- thisModule.resolveTemp(s.refB, 't'),
      "???" <- if not s.cs.oclIsUndefined() then
        s.cs
      else
        OclUndefined
      endif
    ),
    attr : XML!Attribute (
      name <- 'label',
      value <- --Warning: this element was moved in a superclass but the navigation element remain the same
      s.type,
      parent <- t,
      "???" <- if not s.cs.oclIsUndefined() then
        s.cs.size()
      else
        OclUndefined
      endif
    )
}

rule D2Element {
  from
    s : --Warning: element D has been deleted!
    ABC!"???D???(deleted)"
  to
    t : XML!Element (
      name <- 'd',
      value <- s."???d???(top inlined)",
      parent <- thisModule.resolveTemp(s.refB, 't')
    ),
    attr : XML!Attribute (
      name <- 'label',
      value <- s."???d???(top inlined)",
      parent <- t
    )
}

rule E2Element {
  from
    s : --Warning: element E has been deleted!
    ABC!"???E???(deleted)"
  to
    t : XML!Element (
      name <- 'E'
    ),
    attr : XML!Attribute (
      name <- 'label',
      value <- s."???e1???(inlined)" + s."???e2???(inlined)" 
--inline out
      ,
      parent <- t
    )
}

--@Rule for F added class : automatically generated
rule F {
  from
    s_F : XML!F
  to
    t_F : --this module have these metamodels target: Sequence {'XML'}
    XML!"Type your matching element name" (
      "???" <- s_F.d,
      "???" <- s_F.d
    )
} --@End Rule for F added class : automatically generated

