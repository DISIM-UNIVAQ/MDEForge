-- @name			Metamodel composition weaving metamodel
-- @version			1.0
-- @domains			
-- @authors			Ivano Malavolta
-- @date			2009/08/03
-- @description		Weaving metamodel for defining metamodel composition operators.
-- @see				http://dually.di.univaq.it

-- Weaving metamodel defining metamodel composition operators.
-- This metamodel is coupled with the Composition2Ecore.atl transformation
-- that takes as input the left metamodel (leftMM), the right metamodel (rightMM)
-- and the weaving model (WM) and produces a composed metamodel (composedMM) by applying
-- the semantics of the applied operators 

package MetamodelComposition {  

	-- each instance of this class may refer to a preferred (left or right) element
	abstract class PreferenceElement {
	
		-- @subsets child
		attribute preferred : Preference; 
	}
	
	-- specifies whether there is a left, right or no preference for the containing element
	enumeration Preference {
		literal none;
		literal left;
		literal right;
		literal source;
		literal target;
	}
	
	-- this class describe an abstract operator application:
	 class MergeFeatureLink extends WLink {
		
		-- the features to be merged
		
		-- @subsets end
		reference featureSource container : LinkEnd;
		
		-- @subsets end
		reference featureTarget container : LinkEnd;
	}

	-- the root of the weaving model
	class Composition extends WModel, PreferenceElement {
	
		-- references the left metamodel
		
		-- @subsets wovenModel
		reference leftMetamodel container : ModelRef;
		
		-- references the right metamodel
		
		-- @subsets wovenModel
		reference rightMetamodel container : ModelRef;
		
		-- the set of applied composition operators
		
		-- @subsets ownedElement
		reference op[*] container : Operator;

		-- if this evaluates to true then the composed metamodel contains just the leftMetamodel
		-- metaclasses referred by the composition operators and the corresponding portion of leftMetamodel,
		-- otherwise the composed metamodel contains ALL the leftMetamodel metaclasses
		
		-- @subsets child
		attribute sliceLeft : Boolean;	
				
		-- if this evaluates true then the composed metamodel contains just the rightMetamodel
		-- metaclasses referred by the composition operators and the corresponding portion of rightMetamodel,
		-- otherwise the composed metamodel contains ALL the rightMetamodel metaclasses
		
		-- @subsets child
		attribute sliceRight : Boolean;	
		
		-- if this evaluates to true, then the composed metamodel will not contain any info about the structure of
		-- the packages in the metamodels to compose
	
		-- @subsets child
		attribute mergeNamespaces : Boolean;		
	}
	
-------------------------------------------------------------------

	-- @wmodelRefType ModelRef
	class ElementRef extends WElementRef {
	}		
	
	-- @welementRefType ElementRef
	class ModelRef extends WModelRef {
	}
	
	class LinkEnd extends WLinkEnd {
	}

--------------------------------------------------------------------	

	-- this class describe an abstract operator application:
	-- "op"(s, t)
	abstract class Operator extends WLink {
		
		-- the source metaclass s
		
		-- @subsets end
		reference source container : LinkEnd;
		
		-- the target metaclass t
		
		-- @subsets child
		reference target container : LinkEnd;
	}
	
	-- match(s, t) -> c ::: s and t overlap, so they cease to be two distinct metaclasses and
	-- will be merged into a single metaclass c in composedMM;
	--
	-- c contains the union of all the structural features of s and t but the ones specified in
	-- the "ignoring" field of the operator;
	--
	-- the supertypes and subtypes references are unioned too;
	--
	-- if both s and t are abstract(interface) then the resulting metaclass c is abstract(interface),
	-- otherwise it is not abstract (interface);
	class Match extends Operator, PreferenceElement {
		
		-- the name of the merged metaclass; if this attribute is not specified, then the
		-- preferred metaclass's name is chosen, otherwise the name will be the string
		-- concatenation of s.name and t.name (in the latter case a WARNING is raised)
		
		-- @subsets child
		attribute className : String;
		
		-- the set of structural features that are ignored while calculating the union
		-- of the structural features of s and t
		
		-- @subsets end
		reference ignoring[*] container : LinkEnd;
		
		-- the set of structural features that are merged while calculating the union
		-- of the structural features of s and t
		
		-- @subsets end
		reference merging[*] container : MergeFeatureLink;
		
		-- specifies which package should contain the composed metaclass c,
		--if it is not set, then the root package of the composed metamodel will contain the 
		-- composed metaclass
		
		-- @subsets end
		reference namespace[0-1] container : LinkEnd;
	}
	
	-- inherit(s, t) ::: this operator specifies that s will be a subtype of t in the composed metamodel c
	--
	-- technically, this operator adds t to the "supertypes" set of s and checks the absence of cycles
	-- in the inheritance tree
	class Inherit extends Operator {
		
		-- true if t will be abstract (so not instantiable) after applying the inherit operator
		
		-- @subsets child
		attribute abstractTarget : Boolean;
	}
	
	-- expand(s, t) ::: all the attributes of s (leaving out the attributes specified in the
	-- "ignoring" reference) are copied into t;
	-- semantic checks are performed to manage attributes overlapping by name and type
	-- so that the usual attributes merge operation is executed; 
	-- if sliceSource = false, then its atrtibutes are simply copied into t
	-- if sliceSource = true, then s is not copied and:
	-- all the subtypes of s will extend the supertypes of s
	-- all the references whose type is s are deleted from the composed metamodel
	class Expand extends Operator, PreferenceElement {
	
		-- if it is true, then ALL attributes of s (also the inherited ones) are recursively copied into t 
		
		-- @subsets child
		attribute deep : Boolean;
		
		-- if it evaluates to true (default), then the s metaclass cease to exist in composedMM
		-- otherwise it will be part of composedMM
		
		-- @subsets child 
		attribute sliceSource : Boolean;
		
		-- the set of attributes that are ignored while copying the attibutes of s into t
		
		-- @subsets end
		reference ignoring[*] container : LinkEnd;
		
		-- the set of attributes that are merged while copying the attibutes of s into t
		
		-- @subsets end
		reference merging[*] container : MergeFeatureLink;
	}
	
	-- reference(s, t) ::: in composedMM s references t
	--
	-- all the features of the new reference (e.g. lowerbound, name, containment)
	-- can be set while applying this operator;
	--
	-- if the new reference c overlaps an existing one, then c will "override" the old one
	class Reference extends Operator {
	
		-- @subsets child
		attribute changeable : Boolean;	
		
		-- @subsets child
		attribute containment : Boolean;	
		
		-- @subsets child
		attribute derived : Boolean;
		
		-- @subsets end
		reference opposite[0-1] container : LinkEnd;
		
		-- @subsets end
		reference oppositeReference[0-1] : Reference;
		
		-- @subsets child
		attribute lowerBound : Integer;
		
		-- @subsets child
		attribute isOrdered : Boolean;
		
		-- @subsets child
		attribute resolveProxies : Boolean;
		
		-- @subsets child
		attribute transient : Boolean;
		
		-- @subsets child
		attribute isUnique : Boolean;
		
		-- @subsets child
		attribute unsettable : Boolean; 	
		
		-- @subsets child
		attribute upperBound : Integer;
		
		-- @subsets child
		attribute volatile : Boolean;
	}				
}