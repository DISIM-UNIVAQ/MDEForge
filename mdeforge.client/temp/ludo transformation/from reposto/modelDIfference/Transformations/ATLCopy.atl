-- @atlcompiler atl2006
-- Generated by: $Id$
module EModelCopy;

create OUT : OUTMODEL from IN : INMODEL;

helper def : inElements : Set(INMODEL!"ATL::LocatedElement") = INMODEL!"ATL::LocatedElement".allInstancesFrom('IN');

rule "ATL::Unit" {
 from s : INMODEL!"ATL::Unit" (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(INMODEL!"ATL::Unit")
 else false endif)
 to t : OUTMODEL!"ATL::Unit" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 libraries <- s.libraries)
}

rule "ATL::Library" {
 from s : INMODEL!"ATL::Library" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::Library" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 libraries <- s.libraries,
 helpers <- s.helpers)
}

rule "ATL::Query" {
 from s : INMODEL!"ATL::Query" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::Query" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 libraries <- s.libraries,
 body <- s.body,
 helpers <- s.helpers)
}

rule "ATL::Module" {
 from s : INMODEL!"ATL::Module" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::Module" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 isRefining <- s.isRefining,
 libraries <- s.libraries,
 inModels <- s.inModels,
 outModels <- s.outModels,
 elements <- s.elements)
}

rule "ATL::Helper" {
 from s : INMODEL!"ATL::Helper" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::Helper" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 definition <- s.definition)
}

rule "ATL::MatchedRule" {
 from s : INMODEL!"ATL::MatchedRule" (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(INMODEL!"ATL::MatchedRule")
 else false endif)
 to t : OUTMODEL!"ATL::MatchedRule" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 isAbstract <- s.isAbstract,
 isRefining <- s.isRefining,
 isNoDefault <- s.isNoDefault,
 outPattern <- s.outPattern,
 actionBlock <- s.actionBlock,
 variables <- s.variables,
 inPattern <- s.inPattern,
 children <- s.children,
 superRule <- s.superRule)
}

rule "ATL::LazyMatchedRule" {
 from s : INMODEL!"ATL::LazyMatchedRule" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::LazyMatchedRule" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 isAbstract <- s.isAbstract,
 isRefining <- s.isRefining,
 isNoDefault <- s.isNoDefault,
 isUnique <- s.isUnique,
 outPattern <- s.outPattern,
 actionBlock <- s.actionBlock,
 variables <- s.variables,
 inPattern <- s.inPattern,
 children <- s.children,
 superRule <- s.superRule)
}

rule "ATL::CalledRule" {
 from s : INMODEL!"ATL::CalledRule" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::CalledRule" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 isEntrypoint <- s.isEntrypoint,
 isEndpoint <- s.isEndpoint,
 outPattern <- s.outPattern,
 actionBlock <- s.actionBlock,
 variables <- s.variables,
 parameters <- s.parameters)
}

rule "ATL::InPattern" {
 from s : INMODEL!"ATL::InPattern" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::InPattern" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 elements <- s.elements,
 filter <- s.filter)
}

rule "ATL::OutPattern" {
 from s : INMODEL!"ATL::OutPattern" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::OutPattern" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 elements <- s.elements)
}

rule "ATL::SimpleInPatternElement" {
 from s : INMODEL!"ATL::SimpleInPatternElement" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::SimpleInPatternElement" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp,
 "mapsTo" <- s."mapsTo",
 models <- s.models)
}

rule "ATL::SimpleOutPatternElement" {
 from s : INMODEL!"ATL::SimpleOutPatternElement" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::SimpleOutPatternElement" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp,
 sourceElement <- s.sourceElement,
 bindings <- s.bindings,
 model <- s.model,
 reverseBindings <- s.reverseBindings)
}

rule "ATL::ForEachOutPatternElement" {
 from s : INMODEL!"ATL::ForEachOutPatternElement" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::ForEachOutPatternElement" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp,
 sourceElement <- s.sourceElement,
 bindings <- s.bindings,
 model <- s.model,
 collection <- s.collection,
 iterator <- s.iterator)
}

rule "ATL::Binding" {
 from s : INMODEL!"ATL::Binding" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::Binding" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName,
 value <- s.value)
}

rule "ATL::RuleVariableDeclaration" {
 from s : INMODEL!"ATL::RuleVariableDeclaration" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::RuleVariableDeclaration" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp)
}

rule "ATL::LibraryRef" {
 from s : INMODEL!"ATL::LibraryRef" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::LibraryRef" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name)
}

rule "ATL::ActionBlock" {
 from s : INMODEL!"ATL::ActionBlock" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::ActionBlock" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 statements <- s.statements)
}

rule "ATL::ExpressionStat" {
 from s : INMODEL!"ATL::ExpressionStat" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::ExpressionStat" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 expression <- s.expression)
}

rule "ATL::BindingStat" {
 from s : INMODEL!"ATL::BindingStat" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::BindingStat" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 propertyName <- s.propertyName,
 source <- s.source,
 value <- s.value)
}

rule "ATL::IfStat" {
 from s : INMODEL!"ATL::IfStat" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::IfStat" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 condition <- s.condition,
 thenStatements <- s.thenStatements,
 elseStatements <- s.elseStatements)
}

rule "ATL::ForStat" {
 from s : INMODEL!"ATL::ForStat" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"ATL::ForStat" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 iterator <- s.iterator,
 collection <- s.collection,
 statements <- s.statements)
}

rule "OCL::VariableExp" {
 from s : INMODEL!"OCL::VariableExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::VariableExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 referredVariable <- s.referredVariable)
}

rule "OCL::SuperExp" {
 from s : INMODEL!"OCL::SuperExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::SuperExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type)
}

rule "OCL::StringExp" {
 from s : INMODEL!"OCL::StringExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::StringExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 stringSymbol <- s.stringSymbol,
 type <- s.type)
}

rule "OCL::BooleanExp" {
 from s : INMODEL!"OCL::BooleanExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::BooleanExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 booleanSymbol <- s.booleanSymbol,
 type <- s.type)
}

rule "OCL::RealExp" {
 from s : INMODEL!"OCL::RealExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::RealExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 realSymbol <- s.realSymbol,
 type <- s.type)
}

rule "OCL::IntegerExp" {
 from s : INMODEL!"OCL::IntegerExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::IntegerExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 integerSymbol <- s.integerSymbol,
 type <- s.type)
}

rule "OCL::BagExp" {
 from s : INMODEL!"OCL::BagExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::BagExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 elements <- s.elements)
}

rule "OCL::OrderedSetExp" {
 from s : INMODEL!"OCL::OrderedSetExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::OrderedSetExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 elements <- s.elements)
}

rule "OCL::SequenceExp" {
 from s : INMODEL!"OCL::SequenceExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::SequenceExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 elements <- s.elements)
}

rule "OCL::SetExp" {
 from s : INMODEL!"OCL::SetExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::SetExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 elements <- s.elements)
}

rule "OCL::TupleExp" {
 from s : INMODEL!"OCL::TupleExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::TupleExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 tuplePart <- s.tuplePart)
}

rule "OCL::TuplePart" {
 from s : INMODEL!"OCL::TuplePart" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::TuplePart" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp)
}

rule "OCL::MapExp" {
 from s : INMODEL!"OCL::MapExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::MapExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 elements <- s.elements)
}

rule "OCL::MapElement" {
 from s : INMODEL!"OCL::MapElement" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::MapElement" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 key <- s.key,
 value <- s.value)
}

rule "OCL::EnumLiteralExp" {
 from s : INMODEL!"OCL::EnumLiteralExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::EnumLiteralExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule "OCL::OclUndefinedExp" {
 from s : INMODEL!"OCL::OclUndefinedExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::OclUndefinedExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type)
}

rule "OCL::NavigationOrAttributeCallExp" {
 from s : INMODEL!"OCL::NavigationOrAttributeCallExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::NavigationOrAttributeCallExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 source <- s.source)
}

rule "OCL::OperationCallExp" {
 from s : INMODEL!"OCL::OperationCallExp" (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(INMODEL!"OCL::OperationCallExp")
 else false endif)
 to t : OUTMODEL!"OCL::OperationCallExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 operationName <- s.operationName,
 type <- s.type,
 source <- s.source,
 arguments <- s.arguments)
}

rule "OCL::OperatorCallExp" {
 from s : INMODEL!"OCL::OperatorCallExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::OperatorCallExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 operationName <- s.operationName,
 type <- s.type,
 source <- s.source,
 arguments <- s.arguments)
}

rule "OCL::CollectionOperationCallExp" {
 from s : INMODEL!"OCL::CollectionOperationCallExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::CollectionOperationCallExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 operationName <- s.operationName,
 type <- s.type,
 source <- s.source,
 arguments <- s.arguments)
}

rule "OCL::IterateExp" {
 from s : INMODEL!"OCL::IterateExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::IterateExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 source <- s.source,
 body <- s.body,
 iterators <- s.iterators,
 result <- s.result)
}

rule "OCL::IteratorExp" {
 from s : INMODEL!"OCL::IteratorExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::IteratorExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 source <- s.source,
 body <- s.body,
 iterators <- s.iterators)
}

rule "OCL::LetExp" {
 from s : INMODEL!"OCL::LetExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::LetExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 variable <- s.variable,
 in_ <- s.in_)
}

rule "OCL::IfExp" {
 from s : INMODEL!"OCL::IfExp" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::IfExp" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 type <- s.type,
 thenExpression <- s.thenExpression,
 condition <- s.condition,
 elseExpression <- s.elseExpression)
}

rule "OCL::VariableDeclaration" {
 from s : INMODEL!"OCL::VariableDeclaration" (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(INMODEL!"OCL::VariableDeclaration")
 else false endif)
 to t : OUTMODEL!"OCL::VariableDeclaration" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp)
}

rule "OCL::Iterator" {
 from s : INMODEL!"OCL::Iterator" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::Iterator" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp)
}

rule "OCL::Parameter" {
 from s : INMODEL!"OCL::Parameter" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::Parameter" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 id <- s.id,
 varName <- s.varName,
 type <- s.type,
 initExpression <- s.initExpression,
 variableExp <- s.variableExp)
}

rule "OCL::CollectionType" {
 from s : INMODEL!"OCL::CollectionType" (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(INMODEL!"OCL::CollectionType")
 else false endif)
 to t : OUTMODEL!"OCL::CollectionType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 elementType <- s.elementType)
}

rule "OCL::OclType" {
 from s : INMODEL!"OCL::OclType" (
 if thisModule.inElements->includes(s) then
 s.oclIsTypeOf(INMODEL!"OCL::OclType")
 else false endif)
 to t : OUTMODEL!"OCL::OclType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule "OCL::StringType" {
 from s : INMODEL!"OCL::StringType" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::StringType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule "OCL::BooleanType" {
 from s : INMODEL!"OCL::BooleanType" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::BooleanType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule "OCL::IntegerType" {
 from s : INMODEL!"OCL::IntegerType" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::IntegerType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule "OCL::RealType" {
 from s : INMODEL!"OCL::RealType" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::RealType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule "OCL::BagType" {
 from s : INMODEL!"OCL::BagType" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::BagType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 elementType <- s.elementType)
}

rule "OCL::OrderedSetType" {
 from s : INMODEL!"OCL::OrderedSetType" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::OrderedSetType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 elementType <- s.elementType)
}

rule "OCL::SequenceType" {
 from s : INMODEL!"OCL::SequenceType" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::SequenceType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 elementType <- s.elementType)
}

rule "OCL::SetType" {
 from s : INMODEL!"OCL::SetType" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::SetType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 elementType <- s.elementType)
}

rule "OCL::OclAnyType" {
 from s : INMODEL!"OCL::OclAnyType" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::OclAnyType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule "OCL::TupleType" {
 from s : INMODEL!"OCL::TupleType" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::TupleType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 attributes <- s.attributes)
}

rule "OCL::TupleTypeAttribute" {
 from s : INMODEL!"OCL::TupleTypeAttribute" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::TupleTypeAttribute" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type)
}

rule "OCL::OclModelElement" {
 from s : INMODEL!"OCL::OclModelElement" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::OclModelElement" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 model <- s.model)
}

rule "OCL::MapType" {
 from s : INMODEL!"OCL::MapType" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::MapType" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 type <- s.type,
 valueType <- s.valueType,
 keyType <- s.keyType)
}

rule "OCL::OclFeatureDefinition" {
 from s : INMODEL!"OCL::OclFeatureDefinition" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::OclFeatureDefinition" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 feature <- s.feature,
 context_ <- s.context_)
}

rule "OCL::OclContextDefinition" {
 from s : INMODEL!"OCL::OclContextDefinition" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::OclContextDefinition" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 context_ <- s.context_)
}

rule "OCL::Attribute" {
 from s : INMODEL!"OCL::Attribute" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::Attribute" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 initExpression <- s.initExpression,
 type <- s.type)
}

rule "OCL::Operation" {
 from s : INMODEL!"OCL::Operation" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::Operation" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 parameters <- s.parameters,
 returnType <- s.returnType,
 body <- s.body)
}

rule "OCL::OclModel" {
 from s : INMODEL!"OCL::OclModel" (thisModule.inElements->includes(s))
 to t : OUTMODEL!"OCL::OclModel" (
 location <- s.location,
 commentsBefore <- s.commentsBefore,
 commentsAfter <- s.commentsAfter,
 name <- s.name,
 metamodel <- s.metamodel,
 elements <- s.elements,
 model <- s.model)
}

